<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RedIce&#39;s Blog</title>
  
  <subtitle>kirakirari☆~</subtitle>
  <link href="https://red-ice-drhi.github.io/atom.xml" rel="self"/>
  
  <link href="https://red-ice-drhi.github.io/"/>
  <updated>2025-03-24T13:19:24.572Z</updated>
  <id>https://red-ice-drhi.github.io/</id>
  
  <author>
    <name>RI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mc赛船系统</title>
    <link href="https://red-ice-drhi.github.io/2025/03/23/mc-boat-race-system/"/>
    <id>https://red-ice-drhi.github.io/2025/03/23/mc-boat-race-system/</id>
    <published>2025-03-22T17:43:28.000Z</published>
    <updated>2025-03-24T13:19:24.572Z</updated>
    
    <content type="html"><![CDATA[<p>这次来玩mc的datapack，做一个增强版的赛船系统</p><p>使用版本为1.21.4</p><p>在这记录这个赛船系统的制作过程</p><span id="more"></span><p>我希望它能够实现以下功能：</p><p><strong>显示速度，计时等信息</strong></p><p><strong>与多个变量相关的集气</strong></p><p><strong>脱轨、碰撞的判定（用于氮气丢失）</strong></p><p><strong>以铺蓝冰实现加速的氮气释放</strong></p><p><strong>快捷的赛道起点终点设置</strong></p><p><strong>比赛开始，计时，结算等</strong></p><p><strong>比赛影像记录，播放和挑战</strong></p><p>我之前做过一个基础的datapack，它能够显示速度，有集气和氮气加速的功能</p><p>不过那玩意比较简单粗暴，它通过计分板准则minecraft.custom:minecraft.boat_one_cm</p><p>每个游戏刻切片并清零来做速度表</p><p>然后在最后记录这一刻的速度，到了下一个游戏刻就是上一刻的速度</p><p>相减得到加速度</p><p>然后将负的加速度加和起来就是氮气值</p><p>暴力地舍弃过大的加速度（太大基本因为是跳表、脱轨或是碰撞）</p><p>我对这个旧版不是很满意，而且里面的构造确实屎山，我都不想改</p><p>所以直接开新的</p><h3 id="速度表"><a href="#速度表" class="headerlink" title="速度表"></a>速度表</h3><p>这个原理和旧版一样，是用计分准则来实现的</p><p>不过拿来给人看是足够了，我甚至直接把旧版的搬过来</p><p>每个玩家只有一个actionbar，所以dummy创建一个actionbar计分板</p><p>还有速度计分板，上一刻速度，加速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/load.mcfunction</span><br><span class="line"></span><br><span class="line">scoreboard objectives add actionbar dummy</span><br><span class="line"></span><br><span class="line">scoreboard objectives add boat_acceleration_present dummy</span><br><span class="line"></span><br><span class="line">scoreboard objectives add boat_speed_present minecraft.custom:minecraft.boat_one_cm</span><br><span class="line">scoreboard objectives add boat_speed_last_tick dummy</span><br></pre></td></tr></table></figure><p>不同的数字对应不同的actionbar显示模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/actionbar.mcfunction</span><br><span class="line"></span><br><span class="line">execute if score @s actionbar matches 1 at @s run function boat_speed_monitor:speed_monitor_1</span><br><span class="line">execute if score @s actionbar matches 2 at @s run function boat_speed_monitor:speed_monitor_2</span><br></pre></td></tr></table></figure><p>里面有两种速度表，第一个是我新做的用于调试的速度表，第二个就是旧版的直接搬过来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#data/boat_speed_monitor/function/speed_monitor_1.mcfunction</span><br><span class="line"></span><br><span class="line">title @s actionbar [&#123;&quot;text&quot;:&quot;speed: &quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_speed_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot; acceleration: &quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_acceleration_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot; v_vec: [&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;v_vec0_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;v_vec1_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;v_vec2_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;]&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;text&quot;:&quot; a_vec: [&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;a_vec0_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;a_vec1_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;a_vec2_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;]&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;text&quot;:&quot; facing_vec: [&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;facing_vec0_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;facing_vec1_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;facing_vec2_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;]&quot;,&quot;color&quot;:&quot;green&quot;&#125;]</span><br><span class="line"></span><br><span class="line">#&#123;&quot;text&quot;:&quot;speed: &quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_speed_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;</span><br><span class="line">#速度显示</span><br><span class="line"></span><br><span class="line">#&#123;&quot;text&quot;:&quot; acceleration: &quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_acceleration_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;</span><br><span class="line">#加速度显示</span><br><span class="line"></span><br><span class="line">#&#123;&quot;text&quot;:&quot; v_vec: [&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;v_vec0_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;v_vec1_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;v_vec2_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;]&quot;,&quot;color&quot;:&quot;green&quot;&#125;</span><br><span class="line">#速度向量显示</span><br><span class="line"></span><br><span class="line">#&#123;&quot;text&quot;:&quot; a_vec: [&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;a_vec0_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;a_vec1_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;a_vec2_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;]&quot;,&quot;color&quot;:&quot;green&quot;&#125;</span><br><span class="line">#加速度向量显示</span><br><span class="line"></span><br><span class="line">&#123;&quot;text&quot;:&quot; facing_vec: [&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;facing_vec0_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;facing_vec1_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;,&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;facing_vec2_p&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;]&quot;,&quot;color&quot;:&quot;green&quot;&#125;</span><br><span class="line">#朝向向量显示</span><br></pre></td></tr></table></figure><p>因为我是做了几个模块后才开始写这个md，速度向量，加速度向量，和朝向向量后面会给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#data/boat_speed_monitor/function/speed_monitor_2.mcfunction</span><br><span class="line"></span><br><span class="line">execute if score @s boat_speed_present matches 0..79 run title @s actionbar [&#123;&quot;text&quot;:&quot;速度：&quot;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_speed_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;green&quot;&#125;,&#123;&quot;text&quot;:&quot;cm/tick&quot;,&quot;color&quot;:&quot;green&quot;&#125;]</span><br><span class="line">execute if score @s boat_speed_present matches 80..159 run title @s actionbar [&#123;&quot;text&quot;:&quot;速度：&quot;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_speed_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;gold&quot;&#125;,&#123;&quot;text&quot;:&quot;cm/tick&quot;,&quot;color&quot;:&quot;gold&quot;&#125;]</span><br><span class="line">execute if score @s boat_speed_present matches 160..239 run title @s actionbar [&#123;&quot;text&quot;:&quot;速度：&quot;,&quot;color&quot;:&quot;light_purple&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_speed_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;light_purple&quot;&#125;,&#123;&quot;text&quot;:&quot;cm/tick&quot;,&quot;color&quot;:&quot;light_purple&quot;&#125;]</span><br><span class="line">execute if score @s boat_speed_present matches 240..319 run title @s actionbar [&#123;&quot;text&quot;:&quot;速度：&quot;,&quot;color&quot;:&quot;red&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_speed_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;red&quot;&#125;,&#123;&quot;text&quot;:&quot;cm/tick&quot;,&quot;color&quot;:&quot;red&quot;&#125;]</span><br><span class="line">execute if score @s boat_speed_present matches 320.. run title @s actionbar [&#123;&quot;text&quot;:&quot;速度：&quot;,&quot;color&quot;:&quot;dark_purple&quot;&#125;,&#123;&quot;score&quot;:&#123;&quot;objective&quot;:&quot;boat_speed_present&quot;,&quot;name&quot;:&quot;@s&quot;&#125;,&quot;color&quot;:&quot;dark_purple&quot;&#125;,&#123;&quot;text&quot;:&quot;cm/tick&quot;,&quot;color&quot;:&quot;dark_purple&quot;&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就是直接从我以前做的包扒过来的，我挺满意这个</p><p>一开始我在想</p><p>集气系统应该跟这几个变量相关</p><p>加速度大小，速度大小，速度方向与船头方向的夹角大小</p><p>那肯定只用这两个变量是不够，因为缺少了方向</p><p>而且我觉得加速度的精度有点不够，因为这样得到的加速度绝对值基本只在0到4</p><p>计分板又只给整数，太少了</p><p>（因为船前进的牵引加速度只有0.04m&#x2F;tick^2^）</p><p>我想了想，既然我需要能够描述“方向”，那我不如使用向量？</p><p>终点坐标减去起点坐标就是向量，可能做起来复杂一点，但不是不能实现</p><p>要得到向量就逃不开计算，要计算就逃不开计分板</p><p>因为计分板只能储存整数，那我必然逃不开精度问题</p><p>考虑什么样的精度比较合适确实让我思考了几天</p><p>1.int只有31位是数据位，如果精度过高，那么坐标范围就会比较有限</p><p>2.百分之一的精度对加速度是不够的</p><p>3.向量运算过程中很容易涉及乘法，我需要尽量保证向量能完整计算一次乘法</p><p>船的速度一般超不过4m&#x2F;tick</p><p>蓝冰的最高速度也就40&#x2F;11&#x3D;3.6363…m&#x2F;tick</p><p>加速度那更小</p><p>然后边想边试，暂时让精度为2^10</p><p>为了让精度比较好改，我把精度全部写在一个函数里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/pos_p_get.mcfunction</span><br><span class="line"></span><br><span class="line">execute store result score @s Pos0_p run data get entity @s Pos[0] 1024</span><br><span class="line">execute store result score @s Pos1_p run data get entity @s Pos[1] 1024</span><br><span class="line">execute store result score @s Pos2_p run data get entity @s Pos[2] 1024</span><br><span class="line">#向量倍率来自这里,更改精度改这里就好</span><br><span class="line">#1024=2^10，int有31位数据位，所以允许坐标范围在±2^21=±2,097,152内</span><br></pre></td></tr></table></figure><p>既然需要算速度，那自然需要储存上一刻的坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/pos_lt_get.mcfunction</span><br><span class="line"></span><br><span class="line">scoreboard players operation @s Pos0_lt = @s Pos0_p</span><br><span class="line">scoreboard players operation @s Pos1_lt = @s Pos1_p</span><br><span class="line">scoreboard players operation @s Pos2_lt = @s Pos2_p</span><br></pre></td></tr></table></figure><p>这个函数需要放在tick的最后部分执行</p><p>接下来把pos_p减去pos_lt就能得到v_p当前游戏刻速度向量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/v_vec_p_get.mcfunction</span><br><span class="line"></span><br><span class="line">scoreboard players operation @s v_vec0_p = @s Pos0_p</span><br><span class="line">scoreboard players operation @s v_vec1_p = @s Pos1_p</span><br><span class="line">scoreboard players operation @s v_vec2_p = @s Pos2_p</span><br><span class="line"></span><br><span class="line">scoreboard players operation @s v_vec0_p -= @s Pos0_lt</span><br><span class="line">scoreboard players operation @s v_vec1_p -= @s Pos1_lt</span><br><span class="line">scoreboard players operation @s v_vec2_p -= @s Pos2_lt</span><br></pre></td></tr></table></figure><p>同理，获取上一刻速度向量v_lt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/v_vec_lt_get.mcfunction</span><br><span class="line"></span><br><span class="line">scoreboard players operation @s v_vec0_lt = @s v_vec0_p</span><br><span class="line">scoreboard players operation @s v_vec1_lt = @s v_vec1_p</span><br><span class="line">scoreboard players operation @s v_vec2_lt = @s v_vec2_p</span><br></pre></td></tr></table></figure><p>然后获取加速度向量a_p</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/a_vec_p_get.mcfunction</span><br><span class="line"></span><br><span class="line">scoreboard players operation @s a_vec0_p = @s v_vec0_p</span><br><span class="line">scoreboard players operation @s a_vec1_p = @s v_vec1_p</span><br><span class="line">scoreboard players operation @s a_vec2_p = @s v_vec2_p</span><br><span class="line"></span><br><span class="line">scoreboard players operation @s a_vec0_p -= @s v_vec0_lt</span><br><span class="line">scoreboard players operation @s a_vec1_p -= @s v_vec1_lt</span><br><span class="line">scoreboard players operation @s a_vec2_p -= @s v_vec2_lt</span><br></pre></td></tr></table></figure><h3 id="脱轨、碰撞判定"><a href="#脱轨、碰撞判定" class="headerlink" title="脱轨、碰撞判定"></a>脱轨、碰撞判定</h3><p>本来的想法就比较直接</p><p>看看船的侧边、下方、侧边下方有没有非法方块</p><p>但是发现这玩意不好定义啊</p><p>侧边可以是类似火把，按钮，压力板一类不影响碰撞的方块，下边是冰一样能跑</p><p>也可以是像栅栏一样碰撞箱不完整的方块</p><p>（然后就有了个废稿type1）</p><p>那还不如只看下方和侧边下方的方块</p><p>如果没有墙那就只要在赛道侧边放一个方块就能表示边界</p><p>如果有墙就只需要在墙下边放一个方块就好，效果一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#data/wall_hit_judge/function/type2/judge.mcfunction</span><br><span class="line"></span><br><span class="line">#这个方案通过检测脚底和船侧底下的方块来检测是否出轨</span><br><span class="line"></span><br><span class="line">scoreboard players set @s wall_hit_judge 1</span><br><span class="line">execute on vehicle at @s if block ~ ~-0.01 ~ #wall_hit_judge:boat_can_run_on if block ~0.68751 ~-0.01 ~ #wall_hit_judge:boat_can_run_on if block ~ ~-0.01 ~0.68751 #wall_hit_judge:boat_can_run_on if block ~-0.68751 ~-0.01 ~ #wall_hit_judge:boat_can_run_on if block ~ ~-0.01 ~-0.68751 #wall_hit_judge:boat_can_run_on if block ~0.68751 ~-0.01 ~0.68751 #wall_hit_judge:boat_can_run_on if block ~-0.68751 ~-0.01 ~-0.68751 #wall_hit_judge:boat_can_run_on if block ~-0.68751 ~-0.01 ~0.68751 #wall_hit_judge:boat_can_run_on if block ~0.68751 ~-0.01 ~-0.68751 #wall_hit_judge:boat_can_run_on if block ~0.6875 ~-0.01 ~0.68751 #wall_hit_judge:boat_can_run_on if block ~0.68751 ~-0.01 ~0.6875 #wall_hit_judge:boat_can_run_on if block ~0.68751 ~-0.01 ~-0.6875 #wall_hit_judge:boat_can_run_on if block ~0.6875 ~-0.01 ~-0.68751 #wall_hit_judge:boat_can_run_on if block ~-0.6875 ~-0.01 ~0.68751 #wall_hit_judge:boat_can_run_on if block ~-0.68751 ~-0.01 ~-0.6875 #wall_hit_judge:boat_can_run_on if block ~-0.68751 ~-0.01 ~0.6875 #wall_hit_judge:boat_can_run_on if block ~-0.6875 ~-0.01 ~0.68751 #wall_hit_judge:boat_can_run_on on passengers at @s run scoreboard players set @s wall_hit_judge 0</span><br><span class="line">#(0,0,0),(1.1,0,0),(0,0,1.1),(-1.1,0,0),(0,0,-1.1),(1.1,0,1.1),(-1.1,0,-1.1),(-1.1,0,1.1),(1.1,0,-1.1),(1,1.1),(1.1,1),(1.1,-1),(1,-1.1),(-1,-1.1),(-1.1,-1),(-1.1,1),(-1,1.1)</span><br><span class="line"></span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~2 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~2 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~2 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~2 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~2 ~-0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~2 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~2 ~-0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~2 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~2 ~-0.68751</span><br><span class="line"></span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~1.5 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~1.5 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~1.5 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~1.5 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~1.5 ~-0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~1.5 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~1.5 ~-0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~1.5 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~1.5 ~-0.68751</span><br><span class="line"></span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~1 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~1 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~1 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~1 ~</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~ ~1 ~-0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~1 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~1 ~-0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~-0.68751 ~1 ~0.68751</span><br><span class="line">#execute on vehicle at @s run particle dust&#123;color:16755200,scale:0.4&#125; ~0.68751 ~1 ~-0.68751</span><br></pre></td></tr></table></figure><p>下边一坨注释是用来坐标测试的，不重要</p><p>大体意思就是一开始先把判定值设为1，如果每个判定点的方块都属于#wall_hit_judge:boat_can_run_on，那就把判定值设为0</p><p>判定值为1代表脱轨，0代表正常</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#data/wall_hit_judge/tags/block/boat_can_run_on</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;#minecraft:air&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;#minecraft:ice&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;minecraft:water&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>为了在撞墙后触发事件，我自然需要记录上一刻的碰撞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/tick.mcfunction</span><br><span class="line"></span><br><span class="line">execute as @a at @s run scoreboard players operation @s wall_hit_judge_lt = @s wall_hit_judge</span><br></pre></td></tr></table></figure><p>然后用一个新函数规定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##data/wall_hit_judge/function/oot_event.mcfunction</span><br><span class="line"></span><br><span class="line">#oot=out of track</span><br><span class="line"></span><br><span class="line">playsound minecraft:block.fire.extinguish voice @s ~ ~ ~ 100 2</span><br><span class="line"></span><br><span class="line">#现在只有播放熄火音效的功能，剩下丢失集气的内容等集气系统写好了再规定</span><br></pre></td></tr></table></figure><p>事件触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#data/common/function/tick.mcfunction</span><br><span class="line"></span><br><span class="line">execute as @a at @s if score @s wall_hit_judge matches 1 if score @s wall_hit_judge_lt matches 0 run function wall_hit_judge:oot_event</span><br></pre></td></tr></table></figure><p>先睡了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次来玩mc的datapack，做一个增强版的赛船系统&lt;/p&gt;
&lt;p&gt;使用版本为1.21.4&lt;/p&gt;
&lt;p&gt;在这记录这个赛船系统的制作过程&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GHCTF2025</title>
    <link href="https://red-ice-drhi.github.io/2025/03/16/GHCTF2025/"/>
    <id>https://red-ice-drhi.github.io/2025/03/16/GHCTF2025/</id>
    <published>2025-03-15T17:38:13.000Z</published>
    <updated>2025-03-19T13:23:48.101Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章用于研究GHCTF2025的题目</p><span id="more"></span><h2 id="crypto">CRYPTO</h2><h3 id="ez-fermat">EZ-Fermat</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime, bytes_to_long</span><br><span class="line">from secret import f</span><br><span class="line"></span><br><span class="line">flag = b&#x27;NSSCTF&#123;test_flag&#125;&#x27;</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = ZZ[]</span><br><span class="line">f = R(str(f))</span><br><span class="line"></span><br><span class="line">w = pow(2,f(p),n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(f&#x27;&#123;n = &#125;\n&#x27;)</span><br><span class="line">print(f&#x27;&#123;e = &#125;\n&#x27;)</span><br><span class="line">print(f&#x27;&#123;c = &#125;\n&#x27;)</span><br><span class="line">print(f&#x27;&#123;f = &#125;\n&#x27;)</span><br><span class="line">print(f&#x27;&#123;w = &#125;\n&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047</span><br><span class="line">e = 65537</span><br><span class="line">c = 77538275949900942020886849496162539665323546686749270705418870515132296087721218282974435210763225488530925782158331269160555819622551413648073293857866671421886753377970220838141826468831099375757481041897142546760492813343115244448184595644585857978116766199800311200819967057790401213156560742779242511746</span><br><span class="line">f = 2*x^332 - x^331 + x^329 + 3*x^328 - x^327 - 3*x^325 + x^323 - 3*x^322 - x^321 - 3*x^320 + x^319 + 2*x^318 - 4*x^317 - 3*x^315 - 2*x^314 + x^313 + x^312 + 2*x^311 + 2*x^309 + 2*x^308 + 5*x^307 + 2*x^306 + 3*x^305 + 5*x^304 + 4*x^303 + x^302 - x^301 - x^300 - 2*x^299 - 2*x^298 + x^297 + 3*x^296 - x^295 - 4*x^292 - x^290 + 4*x^289 - x^287 - 3*x^286 + x^285 - 2*x^284 + x^283 - x^282 - 2*x^281 + x^280 - 2*x^279 + x^278 + 2*x^277 - 3*x^276 - x^275 - 4*x^274 - 3*x^273 - 5*x^272 - 2*x^271 - 3*x^270 + 2*x^269 + 2*x^268 - x^267 - 2*x^266 + x^265 + x^264 - 3*x^262 - 3*x^259 + 2*x^258 - x^257 + 2*x^256 + 2*x^255 - x^254 - 2*x^253 - x^252 + 2*x^251 - x^250 + x^249 + 2*x^247 + 2*x^246 + 2*x^245 - 2*x^244 - 3*x^243 + 2*x^242 - 3*x^241 - x^240 - 3*x^239 - x^236 - 3*x^235 - 2*x^234 - x^233 - 2*x^232 - x^231 - 3*x^230 - 2*x^229 - 4*x^228 - 2*x^227 - 3*x^226 + 2*x^225 + x^224 - x^223 - 2*x^221 + 3*x^219 - x^217 - 2*x^216 + x^215 + 2*x^213 - x^212 + 3*x^211 + x^210 + 4*x^209 + x^208 - x^206 - x^205 - x^204 + 2*x^203 - 3*x^202 + 2*x^199 - x^198 + 2*x^196 - 2*x^195 + 3*x^194 + 3*x^193 - x^192 + 4*x^191 + 2*x^189 + x^186 - x^185 - x^184 + 3*x^183 + x^182 + 2*x^181 - 2*x^180 + x^177 + x^175 - x^173 + 3*x^172 + x^170 + x^169 - x^167 - 2*x^166 - x^165 - 4*x^164 - 2*x^163 + 2*x^162 + 4*x^161 - 2*x^160 - 3*x^159 - 2*x^158 - 2*x^157 + x^156 - x^155 + 3*x^154 - 4*x^153 + x^151 + 2*x^150 + x^149 - x^148 + 2*x^147 + 3*x^146 + 2*x^145 - 4*x^144 - 4*x^143 + x^142 - 2*x^140 - 2*x^139 + 2*x^138 + 3*x^137 + 3*x^136 + 3*x^135 + x^134 - x^133 + 2*x^132 + 3*x^130 - 3*x^129 - 2*x^128 - x^127 - 2*x^126 + x^125 + x^124 - 2*x^123 + x^122 - x^121 + 3*x^120 - x^119 - 2*x^118 - x^117 - x^116 - 2*x^115 + 2*x^114 + 2*x^113 - 3*x^112 - x^111 - 4*x^110 + x^109 + x^108 + x^106 - 4*x^105 + x^104 - x^103 - x^101 + x^100 - 2*x^99 + x^98 - x^97 + 3*x^96 + 3*x^94 - x^93 - x^92 + x^91 - 2*x^90 + x^89 - x^88 + x^87 - x^86 + x^85 + x^84 - x^83 + x^79 - 3*x^78 - 2*x^77 + x^74 + 3*x^73 - x^72 - 3*x^71 - 2*x^70 + x^69 - 3*x^66 + x^65 + x^64 - 4*x^62 - x^61 + x^60 - x^59 + 3*x^58 - x^57 - x^54 + 3*x^53 + x^51 - 3*x^50 - x^49 + 2*x^47 - x^46 - x^44 + x^43 - x^42 - 4*x^41 - 3*x^39 - x^37 - x^36 - 3*x^35 + x^34 + x^33 - 2*x^32 + 2*x^31 - x^30 + 2*x^29 - 2*x^28 - 2*x^27 - x^24 + x^22 - 5*x^21 + 3*x^20 + 2*x^19 - x^18 + 2*x^17 + x^16 - 2*x^15 - 2*x^14 + x^13 + x^12 + 2*x^11 - 3*x^10 + 3*x^9 + 2*x^8 - 4*x^6 - 2*x^5 - 4*x^4 + x^3 - x^2 - 1</span><br><span class="line">w = 32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结题目</p><p>n=p*q，n已知，p，q未知</p><p>e给定为65537（是个质数）</p><p>c=(m^e)%n</p><p>到这为止是很标准的公钥加密</p><p>但还有信息</p><p>f(x)是一个已知多项式</p><p>w=(2^f(p))%n且w已知</p><p>这部分肯定是入手的关键</p><h4 id="模数是可以拆的">模数是可以拆的</h4><p><span class="math display">\[若a≡b\quad(mod\space n)，n=k_1k_2...k_u\newlinea-b=rn=rk_1k_2...k_u\newline所以就有\newline\left\{\begin{aligned}&amp;a≡b\quad(mod\space k_1)\newline&amp;a≡b\quad(mod\space k_2)\newline&amp;...\newline&amp;a≡b\quad(mod\space k_u)\end{aligned}\right.\]</span></p><p>我们可以把同余式模数变成它的因数</p><p>这是个很好用的技巧</p><p>回到题目 <span class="math display">\[w≡2^{f(p)}≡2^{2*p^{332} - p^{331} + p^{329}...- 4*p^4 + p^3 - p^2 -1}\quad (mod\space n)\newline把它拆开\newlinew≡2^{f(p)}\quad (mod\space p)\newlinew≡2^{f(p)}\quad (mod\space q)\newline\]</span> 我们当然希望未知数少一点，所以以模p为研究对象</p><p>同余式不能同取对数，所以肯定不能直接化简</p><p>但实际上题目名字就是提示——费马小定理</p><p>我们要尽可能在指数上凑出(p-1)</p><p>这里要用一个小技巧</p><p>多项式一定能用它的根来因式分解（实际上就是高中的技巧，但我已经高中毕业了，所以失忆了😢）</p><p>x<sup>i</sup>-1一定能够分解成(x-1)(...)的形式</p><p>所以我们只需要给f(p)的每一个项减去一个系数 <spanclass="math display">\[2*p^{332} - p^{331} + p^{329}...- 4*p^4 + p^3 - p^2 - 1\newline=2(p^{332}-1)-(p^{331}-1)+...-(p^2-1)+t\newline=(p-1)g(p)+t\newlineg(p)是什么我不用管因为它一定是整数，会被消掉\newlinet可以让电脑帮我算\newline所以\newlinew≡2^{f(p)}≡2^{(p-1)g(p)+t}≡2^{t}\quad (mod\space p)\newline\]</span> 再瞪两眼可以发现，t实际上就是f(1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=polygen(ZZ,&#x27;x&#x27;)</span><br><span class="line">f = 2*x^332 - x^331 + x^329 + 3*x^328 - x^327 - 3*x^325 + x^323 - 3*x^322 - x^321 - 3*x^320 + x^319 + 2*x^318 - 4*x^317 - 3*x^315 - 2*x^314 + x^313 + x^312 + 2*x^311 + 2*x^309 + 2*x^308 + 5*x^307 + 2*x^306 + 3*x^305 + 5*x^304 + 4*x^303 + x^302 - x^301 - x^300 - 2*x^299 - 2*x^298 + x^297 + 3*x^296 - x^295 - 4*x^292 - x^290 + 4*x^289 - x^287 - 3*x^286 + x^285 - 2*x^284 + x^283 - x^282 - 2*x^281 + x^280 - 2*x^279 + x^278 + 2*x^277 - 3*x^276 - x^275 - 4*x^274 - 3*x^273 - 5*x^272 - 2*x^271 - 3*x^270 + 2*x^269 + 2*x^268 - x^267 - 2*x^266 + x^265 + x^264 - 3*x^262 - 3*x^259 + 2*x^258 - x^257 + 2*x^256 + 2*x^255 - x^254 - 2*x^253 - x^252 + 2*x^251 - x^250 + x^249 + 2*x^247 + 2*x^246 + 2*x^245 - 2*x^244 - 3*x^243 + 2*x^242 - 3*x^241 - x^240 - 3*x^239 - x^236 - 3*x^235 - 2*x^234 - x^233 - 2*x^232 - x^231 - 3*x^230 - 2*x^229 - 4*x^228 - 2*x^227 - 3*x^226 + 2*x^225 + x^224 - x^223 - 2*x^221 + 3*x^219 - x^217 - 2*x^216 + x^215 + 2*x^213 - x^212 + 3*x^211 + x^210 + 4*x^209 + x^208 - x^206 - x^205 - x^204 + 2*x^203 - 3*x^202 + 2*x^199 - x^198 + 2*x^196 - 2*x^195 + 3*x^194 + 3*x^193 - x^192 + 4*x^191 + 2*x^189 + x^186 - x^185 - x^184 + 3*x^183 + x^182 + 2*x^181 - 2*x^180 + x^177 + x^175 - x^173 + 3*x^172 + x^170 + x^169 - x^167 - 2*x^166 - x^165 - 4*x^164 - 2*x^163 + 2*x^162 + 4*x^161 - 2*x^160 - 3*x^159 - 2*x^158 - 2*x^157 + x^156 - x^155 + 3*x^154 - 4*x^153 + x^151 + 2*x^150 + x^149 - x^148 + 2*x^147 + 3*x^146 + 2*x^145 - 4*x^144 - 4*x^143 + x^142 - 2*x^140 - 2*x^139 + 2*x^138 + 3*x^137 + 3*x^136 + 3*x^135 + x^134 - x^133 + 2*x^132 + 3*x^130 - 3*x^129 - 2*x^128 - x^127 - 2*x^126 + x^125 + x^124 - 2*x^123 + x^122 - x^121 + 3*x^120 - x^119 - 2*x^118 - x^117 - x^116 - 2*x^115 + 2*x^114 + 2*x^113 - 3*x^112 - x^111 - 4*x^110 + x^109 + x^108 + x^106 - 4*x^105 + x^104 - x^103 - x^101 + x^100 - 2*x^99 + x^98 - x^97 + 3*x^96 + 3*x^94 - x^93 - x^92 + x^91 - 2*x^90 + x^89 - x^88 + x^87 - x^86 + x^85 + x^84 - x^83 + x^79 - 3*x^78 - 2*x^77 + x^74 + 3*x^73 - x^72 - 3*x^71 - 2*x^70 + x^69 - 3*x^66 + x^65 + x^64 - 4*x^62 - x^61 + x^60 - x^59 + 3*x^58 - x^57 - x^54 + 3*x^53 + x^51 - 3*x^50 - x^49 + 2*x^47 - x^46 - x^44 + x^43 - x^42 - 4*x^41 - 3*x^39 - x^37 - x^36 - 3*x^35 + x^34 + x^33 - 2*x^32 + 2*x^31 - x^30 + 2*x^29 - 2*x^28 - 2*x^27 - x^24 + x^22 - 5*x^21 + 3*x^20 + 2*x^19 - x^18 + 2*x^17 + x^16 - 2*x^15 - 2*x^14 + x^13 + x^12 + 2*x^11 - 3*x^10 + 3*x^9 + 2*x^8 - 4*x^6 - 2*x^5 - 4*x^4 + x^3 - x^2 - 1</span><br><span class="line">t=f(1)</span><br><span class="line">print(t)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样可以得到t=-57</p><p>所以 <span class="math display">\[w≡2^{-57}\quad (mod\space p)\newline也就是\newline2^{57}w≡1\quad (mod\space p)\newline\]</span> 看起来我们已经与p很接近了</p><p>我们要注意到，p是(2<sup>57</sup>w-1)和n的公约数</p><p>由此就可以直接计算（反正用个函数就能算，管它是用欧几里得算法还是其他什么的我暂且不关心）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd</span><br><span class="line">w = <span class="number">32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244</span></span><br><span class="line">n = <span class="number">101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047</span></span><br><span class="line">p=gcd(((<span class="number">2</span>**<span class="number">57</span>)*w)-<span class="number">1</span>,n)</span><br><span class="line">q=n//p</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p=&quot;</span>,p,<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;q=&quot;</span>,q)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p= 10369947696097707510769809078424403635336089844072313788886920079212917663690503014328582816890429888540698699892682697716174207561536836918335963753124197</span><br><span class="line"> q= 9814954995402888157895432394154096303205654905130720582279697302830224692863509115591058838613477077284923737126007566425022731944192591349200677124858051</span><br></pre></td></tr></table></figure><p>这样p和q已经出来了，我们就能直接把这个RSA的底裤扒干净</p><p>所以接下来就是标准的求逆元，算明文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes,inverse</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd</span><br><span class="line">w = <span class="number">32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244</span></span><br><span class="line">n = <span class="number">101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">77538275949900942020886849496162539665323546686749270705418870515132296087721218282974435210763225488530925782158331269160555819622551413648073293857866671421886753377970220838141826468831099375757481041897142546760492813343115244448184595644585857978116766199800311200819967057790401213156560742779242511746</span></span><br><span class="line"></span><br><span class="line">p=gcd(((<span class="number">2</span>**<span class="number">57</span>)*w)-<span class="number">1</span>,n)</span><br><span class="line">q=n//p</span><br><span class="line"><span class="comment">#print(&quot;p=&quot;,p,&quot;\n&quot;,&quot;q=&quot;,q)</span></span><br><span class="line">d=inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">flag=long_to_bytes(m)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#b&#x27;NSSCTF&#123;8d1e3405044a79b23a44a43084bd994b&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="mimt_rsa">MIMT_RSA</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> KEY， flag  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">int</span>(KEY).bit_length() == <span class="number">36</span></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> isPrime(KEY)</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">ck = <span class="built_in">pow</span>(KEY, e, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag == <span class="string">b&#x27;NSSCTF&#123;&#x27;</span> + md5(<span class="built_in">str</span>(KEY).encode()).hexdigest().encode() + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;n = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;ck = &#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 26563847822899403123579768059987758748518109506340688366937229057385768563897579939399589878779201509595131302887212371556759550226965583832707699167542469352676806103999861576255689028708092007726895892953065618536676788020023461249303717579266840903337614272894749021562443472322941868357046500507962652585875038973455411548683247853955371839865042918531636085668780924020410159272977805762814306445393524647460775620243065858710021030314398928537847762167177417552351157872682037902372485985979513934517709478252552309280270916202653365726591219198063597536812483568301622917160509027075508471349507817295226801011</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">ck = 8371316287078036479056771367631991220353236851470185127168826270131149168993253524332451231708758763231051593801540258044681874144589595532078353953294719353350061853623495168005196486200144643168051115479293775329183635187974365652867387949378467702492757863040766745765841802577850659614528558282832995416523310220159445712674390202765601817050315773584214422244200409445854102170875265289152628311393710624256106528871400593480435083264403949059237446948467480548680533474642869718029551240453665446328781616706968352290100705279838871524562305806920722372815812982124238074246044446213460443693473663239594932076</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition, message</span><br></pre></td></tr></table></figure><p>assert的意思就是condition满足什么也不会干，condition不满足就以message的信息报错</p><p>总结题目：</p><p>p，q是1024位的大质数，n=pq，n已知，p，q未知</p><p>ck=pow(KEY,e,n)，知道ck的值，KEY是36位的整数且不是质数</p><p>（ck是密文，KEY是明文）</p><p>目的是解KEY</p><p>确实，这道题的操作有点骚，要先射箭再画靶</p><p>直接爆明文看符不符合加密结果（主要原因是KEY是题目里面几个数字里看起来最好欺负的那个）</p><p>但36位直接爆还是有点瘆人</p><p>但KEY不是质数，所以按假定因数a，b拆 <span class="math display">\[ck≡KEY^{e}\quad(mod\space n)⇨ck≡(ab)^{e}\quad(mod\space n)\newline⇨ck*b^{-e}≡a^{e}\quad(mod\space n)\]</span> 为什么这样做能降低穷举量？</p><h4 id="中间相遇攻击mitm">中间相遇攻击(MITM)</h4><p>若有加密函数E和解密函数D，ED对称</p><p>未知密钥k<sub>1</sub>，k<sub>2</sub>，假设它们各有K种取值可能</p><p>对于已知密文C，P有 <span class="math display">\[C=E_{k_{2}}(E_{k_{1}}(P))\newline或是\newlineP=D_{k_{2}}(D_{k_{1}}(C))\newline\]</span> 我们想要知道k<sub>1</sub>，k<sub>2</sub></p><p>如果真的硬来，那就是每一种k<sub>1</sub>，k<sub>2</sub>的组合我们都要尝试一遍，那就得枚举K<sup>2</sup>种情况</p><p>MITM就提供了一种减少枚举时间的方式</p><p>比起尝试k<sub>1</sub>*k<sub>2</sub>，不如尝试k<sub>1</sub>+k<sub>2</sub><span class="math display">\[D_{k_{2}}(C)=E_{k_{1}}(P)=M\]</span>我们先尝试用K种k<sub>2</sub>对C解密，并将每种k<sub>2</sub>对M储存起来</p><p>同样尝试K种k<sub>1</sub>对P加密，并将每种k<sub>1</sub>对M储存起来</p><p>（Python里貌似管这个储存起来的配对关系称为字典）</p><p>然后在两个字典里寻找M相同的那一对k<sub>1</sub>，k<sub>2</sub></p><p>这样子枚举情况就变成了2K，就算再加上查找，差不多也就4K，在K足够大的情况下能够大量节省枚举时间</p><p>这个东西比起技巧更像个思考方式，因为比较抽象</p><p>回到题目</p><p><span class="math display">\[ck≡KEY^{e}\quad(mod\space n)⇨ck≡(ab)^{e}\quad(mod\space n)\newline⇨ck*b^{-e}≡a^{e}\quad(mod\space n)\]</span> 要想清楚，a，b是对称的变量</p><p>假设这么一个问题 <span class="math display">\[f+g=100\newlinef=100-g\]</span> 当我们寻找f，g的正整数解真的需要在f身上历遍1到99吗</p><p>显然不需要，f只需要试1到50就行了，因为f和g是对称的</p><p>我们在f身上历遍1到50的时候，g已经历遍99到50了</p><p>所以在原题目中ab=KEY，那我们只需要在a身上历遍差不多1到KEY<sup>0.5</sup>就行了</p><p>或者说 <span class="math display">\[ck*KEY^{-e}≡1^{e}\quad(mod\space n)\newlineck*1^{-e}≡KEY^{e}\quad(mod\space n)\]</span> 这两个等式一定是同时成立的</p><p>所以这样子我们枚举的情况就能从2<sup>35</sup>种缩减为差不多2<sup>19</sup>？</p><p>总之将近一半</p><p>（我猜测不能拆多个因数是因为一个是不确定KEY有几个因数，一个是等号，同余号只有两侧）</p><p>所以现在就让我们在1到2<sup>19</sup>的范围内穷举a和b</p><p>嗯，本来是这么想的，但我在尝试中发现不扩到20位是找不到的，我想不出原因</p><p>反正折半找不到就扩一两位吧，差不了太多</p><h4 id="生成器表达式">生成器表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition)</span><br></pre></td></tr></table></figure><p>expression是它的输出值</p><p>item是它历遍的元素，可以类比for语句里的循环变量</p><p>interable是可迭代对象（如列表、字典、集合等）</p><p>condition是限制条件，只有符合条件的会被生成器选中</p><p>example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list1=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line">list2=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>) <span class="keyword">if</span> x%<span class="number">3</span>==<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[1, 4, 9, 16]</span></span><br><span class="line"><span class="comment">#[3, 6, 9, 12, 15, 18]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange</span><br><span class="line"></span><br><span class="line">n = <span class="number">26563847822899403123579768059987758748518109506340688366937229057385768563897579939399589878779201509595131302887212371556759550226965583832707699167542469352676806103999861576255689028708092007726895892953065618536676788020023461249303717579266840903337614272894749021562443472322941868357046500507962652585875038973455411548683247853955371839865042918531636085668780924020410159272977805762814306445393524647460775620243065858710021030314398928537847762167177417552351157872682037902372485985979513934517709478252552309280270916202653365726591219198063597536812483568301622917160509027075508471349507817295226801011</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">ck = <span class="number">8371316287078036479056771367631991220353236851470185127168826270131149168993253524332451231708758763231051593801540258044681874144589595532078353953294719353350061853623495168005196486200144643168051115479293775329183635187974365652867387949378467702492757863040766745765841802577850659614528558282832995416523310220159445712674390202765601817050315773584214422244200409445854102170875265289152628311393710624256106528871400593480435083264403949059237446948467480548680533474642869718029551240453665446328781616706968352290100705279838871524562305806920722372815812982124238074246044446213460443693473663239594932076</span></span><br><span class="line"></span><br><span class="line">f1=&#123;&#125;</span><br><span class="line">f2=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> trange(<span class="number">1</span>,<span class="number">2</span>**<span class="number">20</span>):</span><br><span class="line">    f1[a]=<span class="built_in">pow</span>(a,e,n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> trange(<span class="number">1</span>,<span class="number">2</span>**<span class="number">20</span>):</span><br><span class="line">    f2[b]=(ck*<span class="built_in">pow</span>(b,-e,n))%n</span><br><span class="line"><span class="comment">#a(b (mod n)) (mod n)=ab (mod n)</span></span><br><span class="line"></span><br><span class="line">inter=(<span class="built_in">set</span>(f1.values())).intersection(<span class="built_in">set</span>(f2.values()))</span><br><span class="line"><span class="comment">#f1.values返回f1内的值构成的列表</span></span><br><span class="line"><span class="comment">#同理，f1.keys返回f1内键构成的列表</span></span><br><span class="line"><span class="comment">#set()函数可以将括号内的内容转化为集合，集合可以计算交集，并集等</span></span><br><span class="line"><span class="comment">#set1.intersection(set2)会返回两个集合的交集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inter:</span><br><span class="line">    a=<span class="built_in">next</span>(k <span class="keyword">for</span> k,v <span class="keyword">in</span> f1.items() <span class="keyword">if</span> v==i)</span><br><span class="line">    <span class="comment">#f1.items()返回f1内的键值对</span></span><br><span class="line">    <span class="comment">#k,v在f1内的键值对循环，如果找到v和i相等，则返回对应的k加入列表，最后返回列表</span></span><br><span class="line">    <span class="comment">#这个k,v并无特别含义，，改成(g for g,h in f1.items() if h==i)也没有问题</span></span><br><span class="line">    <span class="comment">#在这个程序内，next()仅返回列表里第一个元素的值</span></span><br><span class="line">    b=<span class="built_in">next</span>(k <span class="keyword">for</span> k,v <span class="keyword">in</span> f2.items() <span class="keyword">if</span> v==i)</span><br><span class="line">    KEY=a*b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(KEY)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████| 1048575/1048575 [01:32&lt;00:00, 11299.88it/s]</span></span><br><span class="line"><span class="string">100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████| 1048575/1048575 [03:00&lt;00:00, 5801.39it/s] </span></span><br><span class="line"><span class="string">62495925932</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#next(iterator,default)</span></span><br><span class="line"></span><br><span class="line">gen = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"></span><br><span class="line">gen = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen,<span class="string">&quot;s&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen,<span class="string">&quot;s&quot;</span>))</span><br><span class="line"></span><br><span class="line">gen=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen)) <span class="comment">#开始报错，因为列表不是迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen,<span class="string">&quot;s&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen,<span class="string">&quot;s&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">s</span></span><br><span class="line"><span class="string">s</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>next就是有的输出就按顺序找一个输出，没有就按default输出，如果没得输出又没有default也报错</p><p>每一次列表更改它就会重新计数</p><p>因为生成器对象每个循环都重新生成一次</p><p>所以在解答程序中只会输出交集中第一个符合的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line">KEY=<span class="number">62495925932</span></span><br><span class="line">flag=<span class="string">b&#x27;NSSCTF&#123;&#x27;</span> + md5(<span class="built_in">str</span>(KEY).encode()).hexdigest().encode() + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)    <span class="comment">#b&#x27;NSSCTF&#123;14369380f677abec84ed8b6d0e3a0ba9&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>完事</p><h3 id="sin">Sin</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long; <span class="built_in">print</span>((<span class="number">2</span> * sin((m := bytes_to_long(<span class="string">b&#x27;NSSCTF&#123;test_flag&#125;&#x27;</span>))) - <span class="number">2</span> * ((<span class="number">2</span> * tan(m / <span class="number">2</span>)) / (<span class="number">1</span> + (tan(m / <span class="number">2</span>)) ^ <span class="number">2</span>)) * cos(<span class="number">2</span> * m)).n(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">m的值即为flag</span></span><br><span class="line"><span class="string">0.002127416739298073705574696200593072466561264659902471755875472082922378713642526659977748539883974700909790177123989603377522367935117269828845667662846262538383970611125421928502514023071134249606638896732927126986577684281168953404180429353050907281796771238578083386883803332963268109308622153680934466412</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>m := bytes_to_long(b'NSSCTF{test_flag}'</p><p>:=叫海象运算符，可以用于在表达式中赋值</p><p>用普通赋值的话这个赋值就得单独拎出来写一行</p><p>.n(1024)表示保留1024位的精度</p><p>现在总结一下题目 <span class="math display">\[2sin(m)-2(\frac{2tan\frac{m}{2}}{1+tan^{2}\frac{m}{2}})cos(2m)=c\newlinec已知，求解m\]</span> 对括号对得我脑壳疼</p><p>但不得不说，看到这题我就想起了高中狂算三角函数的日子</p><p>不知道高中的知识还够不够用呢 <span class="math display">\[\frac{2tan\frac{m}{2}}{1+tan^{2}\frac{m}{2}}\newline明显的万能公式，看不出来也能上下同乘cos平方\newline\frac{2tan\frac{m}{2}}{1+tan^{2}\frac{m}{2}}=\frac{2sin\frac{m}{2}cos\frac{m}{2}}{sin^{2}\frac{m}{2}+cos^{2}\frac{m}{2}}=sin(m)\newline代换\newline2sin(m)-2sin(m)cos(2m)=2sin(m)(1-cos(2m))=2sin(m)(1-(1-2sin^{2}(m)))=4sin^{3}(m)=c\newline\]</span> 嘛，到这为止还算高中内容</p><p>接下来就是其他不认识的东西了</p><p>先睡觉，慢慢写...</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章用于研究GHCTF2025的题目&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>[buuctf]-RSA1</title>
    <link href="https://red-ice-drhi.github.io/2025/02/18/buuctf-RSA1/"/>
    <id>https://red-ice-drhi.github.io/2025/02/18/buuctf-RSA1/</id>
    <published>2025-02-18T08:46:48.000Z</published>
    <updated>2025-03-09T11:50:16.425Z</updated>
    
    <content type="html"><![CDATA[<p>由于这题难到我了，所以做个md来记录</p><h3 id="题目内容"><ahref="%5BBUUCTF在线评测%5D(https://buuoj.cn/challenges#RSA1)">1.题目内容</a></h3><p><span class="math display">\[p =8637633767257008567099653486541091171320491509433615\newline447539162437911244175885667806398411790524083553445158113\newline502227745206205327690939504032994699902053229\newline\newlineq =126406749739964727691760479371708834209270508214800\newline1058159313713537247388059561373733763062975257734614703928\newline4030082593490776630572584959954205336880228469\newline\newlinedp =650079570221683462110904235119326153065004384105625\newline2930930949663358625016881832840728066026150264693076109354\newline874099841380454881716097778307268116910582929\newline\newlinedq =783472263673553449019532580386470672380574033551303\newline8891379117604388816836745560980982567956735122019630021754\newline38762767516968043599582527539160811120550041\newline\newlinec =24722305403887382073567316467649080662631552905960\newline22939907910799560215441817605633580063888752761416407353043\newline7657085079676157350205351945222989351316076486\newline5735995760419783398722659250627643185360890073102702785261596\newline78937431903862892400747915525118983959970607\newline934142974736675784325993445942031372107342103852\newline\newline\]</span> 其中 <span class="math display">\[dp=d\%(p-1)\newlinedq=d\%(q-1)\]</span> 已知这些数字，解RSA原文吧 <span id="more"></span></p><p>不得不说这数字比我命还长。。。</p><h3 id="尝试">2.尝试</h3><p>要解密密文，我一开始想的是找私钥d</p><p>思路很简单粗暴——试商</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">caesar_decrypt</span>(<span class="params">p,q,dp,dq,c</span>):   <span class="comment">#函数名我也不知道是什么意思，我只是把上个程序给删到这直接写</span></span><br><span class="line">    n=p*q</span><br><span class="line">    k=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        d=k*(p-<span class="number">1</span>)+dp</span><br><span class="line">        <span class="keyword">if</span> d%(q-<span class="number">1</span>)==dq:   <span class="comment">#如果余数对了，说明这个k就是我要的</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment">#调试       print(k,&quot;   &quot;,d,&quot;   &quot;,(dq-d)%(q-1),&quot;\n&quot;)</span></span><br><span class="line">        k=k+<span class="number">1</span>      <span class="comment">#以k作d除以(p-1)的商，不断尝试</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">pow</span>(c,d,n))   <span class="comment">#返回c的d次方模n，即明文</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span> </span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span> </span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span> </span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span> </span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;caesar_decrypt(p,q,dp,dq,c)&#125;</span>&quot;</span>)   <span class="comment">#f是为了阻止它使用科学计数法</span></span><br></pre></td></tr></table></figure><p>但就从这一堆比我命还长的数就能看出来，结果基本跑不出来</p><p>那只能换个方式</p><p>但我没有思路，只能选择看答案</p><h3 id="不会看答案"><ahref="https://blog.csdn.net/ao52426055/article/details/109304646">3.不会，看答案</a></h3><figure><imgsrc="../img/buuctf-RSA1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-18%20213231.png"alt="屏幕截图 2025-02-18 213231" /><figcaption aria-hidden="true">屏幕截图 2025-02-18 213231</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span></span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span></span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span></span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span></span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">I = gmpy2.invert(q,p)</span><br><span class="line">mp = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">mq = <span class="built_in">pow</span>(c,dq,q)               <span class="comment">#求幂取模运算</span></span><br><span class="line"></span><br><span class="line">m = (((mp-mq)*I)%p)*q+mq       <span class="comment">#求明文公式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(m))          <span class="comment">#转为十六进制</span></span><br></pre></td></tr></table></figure><p>重点应该就是这部分了</p><p>暂且不深究gmpy2库里面有什么</p><p>gmpy2.invert(q,p)返回的是q在模p下的逆元，然后赋值给I，即 <spanclass="math display">\[Iq≡1\quad(mod\space p)\]</span> 然后再定义 <span class="math display">\[mp=c^{dp}\%p\newlinemq=c^{dq}\%q\]</span> 但最后比较疑惑人的是这一步 <span class="math display">\[m = (((mp-mq)*I)\%p)*q+mq       \]</span> 至少我看答案的时候不知道这是个什么</p><h4 id="定理提供">定理提供</h4><h5 id="中国剩余定理">1.中国剩余定理</h5><p>但问问AI就了解到了——中国剩余定理（Chinese Remainder Theorem，CRT）<span class="math display">\[若有一组模数m_{1},m_{2},m_{3}...m_{k},一组余数r_{1},r_{2},r_{3}...r_{k}\newline并且数组m满足其中所有数两两互质(详：∀i≠j，满足i,j∈[1,k]且为整数，则有gcd(m_{i},m_{j})=1)\newline则对关于x的方程组\newline\left\{\begin{aligned}&amp;x≡r_{1}\quad(mod\space m_{1})\newline&amp;x≡r_{2}\quad(mod\space m_{2})\newline&amp;x≡r_{3}\quad(mod\space m_{3})\newline&amp;...\newline&amp;x≡r_{k}\quad(mod\space m_{k})\end{aligned}\right.\newline记M=\prod\limits_{i=1}^{k}{m_i}\newline在[0,M-1]的范围内一定存在唯一整数解x\newline并且这个定理也给出了求解x的方式：\newline1.计算M=\prod\limits_{i=1}^{k}{m_i}\newline2.计算M_i=\frac{M}{m_i}，其中i取遍1到k\newline3.计算y_i，y_i满足M_iy_i≡1\quad(mod\spacem_i)，即y_i是M_i在模M下的逆元。\newline可以使用扩展欧几里得算法来计算逆元\quad(后面会补充说明)\newline4.计算最后结果x\newlinex≡\sum\limits_{i=1}^{k}r_iM_iy_i\quad(mod\space M)\newline取x∈[0,M-1]，即x=(\sum\limits_{i=1}^{k}r_iM_iy_i)\%M\newline、\]</span></p><p>内容并不复杂，但单看内容还是太生硬了，还是有个证明比较舒服</p><p>先证明解是正确的 <span class="math display">\[已知x≡\sum\limits_{i=1}^{k}r_iM_iy_i\quad(mod\spaceM)，且x∈[0,M-1]，求证x满足方程组\newline\left\{\begin{aligned}&amp;x≡r_{1}\quad(mod\space m_{1})\newline&amp;x≡r_{2}\quad(mod\space m_{2})\newline&amp;x≡r_{3}\quad(mod\space m_{3})\newline&amp;...\newline&amp;x≡r_{k}\quad(mod\space m_{k})\end{aligned}\right.\newline、\]</span> 证明： <span class="math display">\[记x=r_1M_1y_1+r_2M_2y_2+...+r_kM_ky_k+jM，其中j∈Z\newline先看特例\quad x≡r_{1}\quad(mod\space m_{1})\newline我们知道\quad M=\prod\limits_{i=1}^{k}{m_i}\quad，\quadM_i=\frac{M}{m_i}=\frac{\prod\limits_{n=1}^{k}{m_n}}{m_i}\newline所以除了M_1,剩下的M_2,M_3...M_k和M都含有因数m_1\newline所以x≡\sum\limits_{i=1}^{k}(r_iM_iy_i)+jM≡r_1M_1y_1\quad(mod\spacem_1)\newline现在只需要证r_1M_1y_1≡r_1\quad(mod\space m_1)\newline已知M_iy_i≡1\quad(mod\space m_i)\space⇨\space M_1y_1-1=fm_1\space⇨\spaceM_1y_1=fm_1+1\newliner_1M_1y_1=r_1(fm_1+1)=r_1fm_1+r_1\newliner_1fm_1显然是m_1的倍数，可以消去，剩下r_1，也就得到了\newlinex≡\sum\limits_{i=1}^{k}(r_iM_iy_i)+jM≡r_1M_1y_1≡r_1\quad(mod\spacem_1)\newline即x≡r_1\quad(mod\space m_1)\newline\]</span> 特例就如此出来了</p><p>当然还没完，我们想要的是通解</p><p>其实也很简单，因为在上面的过程中，我们并没有使用什么特殊的性质，基本只需要把1改成变量<span class="math display">\[记x=r_1M_1y_1+r_2M_2y_2+...+r_kM_ky_k+jM，其中j∈Z\newline需证明\quad x≡r_{t}\quad(mod\spacem_{t})对任意的t∈[1,k]\space\&amp;\space t∈Z成立\newline已知\quad M=\prod\limits_{i=1}^{k}{m_i}\quad，\quadM_t=\frac{M}{m_t}=\frac{\prod\limits_{i=1}^{k}{m_i}}{m_t}\newline除了M_t,剩下的M_1,M_2,M_3...M_k和M都含有因数m_t\newline所以x≡\sum\limits_{i=1}^{k}(r_iM_iy_i)+jM≡r_tM_ty_t\quad(mod\spacem_t)\newline现在只需要证r_tM_ty_t≡r_t\quad(mod\space m_t)\newline已知M_ty_t≡1\quad(mod\space m_t)\space⇨\space M_ty_t-1=fm_t\space⇨\spaceM_ty_t=fm_t+1\newliner_tM_ty_t=r_t(fm_t+1)=r_tfm_t+r_t\newliner_tfm_t显然是m_t的倍数，可以消去，剩下r_t，也就得到了\newlinex≡\sum\limits_{i=1}^{k}(r_iM_iy_i)+jM≡r_tM_ty_t≡r_t\quad(mod\spacem_t)\newline即x≡r_t\quad(mod\space m_t)对于任意t∈[1,k]成立\newline\]</span> 如此，我们就证明了这个解是正确的</p><p>接下来我们证明这个解在[0,M-1]内是唯一的</p><p>唯一证明这种事交给反证法比较好做，因为正着来基本看不出方法，但反过来否定它就比较容易找到逻辑漏洞从而证伪<span class="math display">\[已知方程组\newline\left\{\begin{aligned}&amp;x≡r_{1}\quad(mod\space m_{1})\newline&amp;x≡r_{2}\quad(mod\space m_{2})\newline&amp;x≡r_{3}\quad(mod\space m_{3})\newline&amp;...\newline&amp;x≡r_{k}\quad(mod\space m_{k})\end{aligned}\right.\newline证明这个方程组在[0,M-1]内的解唯一\]</span> 证明： <span class="math display">\[假设这个方程组有多个解x_1,x_2..x_n∈[0,M-1]，其中n∈[2,M](因为0到M-1一共有M个数)\newline那么就有\newline\left\{\begin{aligned}&amp;x_1≡x_2≡...≡x_n\quad(mod\space m_{1})\newline&amp;x_1≡x_2≡...≡x_n\quad(mod\space m_{2})\newline&amp;x_1≡x_2≡...≡x_n\quad(mod\space m_{3})\newline&amp;...\newline&amp;x_1≡x_2≡...≡x_n\quad(mod\space m_{k})\end{aligned}\right.\newline任取两个整数i≠j∈[1,n]\newline有x_i≡x_j\quad(mod\space m_{t})\quad(t是[1,k]内的任意整数)即x_i-x_j是m_1，m_2，m_3...m_k的公倍数\newline又因为数组m所有数两两互质\newline所以m_1，m_2，m_3...m_k的公倍数一定是\prod\limits_{i=1}^{k}{m_i}=M的倍数\quad(后面会补充证明)\newline所以x_i，x_j至少相差一个M\newline但这与x_1,x_2..x_n∈[0,M-1]矛盾，即任意两个解相差不可能大于M-1\newline所以这个解在[0,M-1]必定唯一\]</span></p><h5 id="欧几里得算法">2.欧几里得算法</h5><p>这东西是个求最大公约数的技巧，它的内容就是 <spanclass="math display">\[gcd(a,b)=gcd(a,b\%a)\newline(默认a，b均大于等于0吧，我不太会讨论负数证明)\newline求两数的最大公约数可以用求余来缩小数字\]</span></p><p>在证明这个等式之前，我们先证另一个东西 <span class="math display">\[若a≥0,b≥0,k∈Z且b+ka≥0\newline则(a,b)和(a,b+ka)一定拥有相同的公因数\newline(前提：问(0,0)的公因数没有意义，故默认排除\newlinea≠0，问(a,0)的公因数和问a的因数等价，因为任何数都是0的因数)\]</span> 这个并不复杂，顺着题目来就行</p><p>证明 <span class="math display">\[设表示a和b所有的公因数组成集合A，a和b+ka所有的公因数组成集合B\newline我们要证明A和B等价\newline那就来证A的元素一定在B里面，同时B的元素一定在A里面\newline取∀p∈A,q∈B\newline现证明p∈B\newline有a≡0\quad(mod\space p)⇨ka≡0\quad(mod\spacep)（同余两侧可以同乘非正数），又b≡0\quad(mod\space p)\newline所以b+ka≡0\quad(mod\space p)\newline即p同时是a和b+ka的因数，即a和b+ka的公因数，得p∈B\newline\newline现证明q∈A\newline其实套用上面就好\newlinep∈B说明(a,b)的公因数一定是(a,b+ka)的公因数\newline那么(a,b+ka)的公因数一定是(a,(b+ka)+(-ka)=b)的公因数\newline即q∈A\newline由此，命题得证\]</span> 接下来再进一步，我们证明 <span class="math display">\[若a≥0,b≥0,k∈Z且b+ka≥0\newline则gcd(a,b)=gcd(a,b+ka)\newline(同样的，问gcd(0,0)没有意义,gcd(a,0)是a自身)\]</span> 证明: <span class="math display">\[因为gcd(a,b)是a和b+ka的公因数⇨gcd(a,b)≤gcd(a,b+ka)\newline因为gcd(a,b+ka)是a和b的公因数⇨gcd(a,b+ka)≤gcd(a,b)\newline所以只能有gcd(a,b)=gcd(a,b+ka)\newline命题得证\]</span>这么做完，欧几里得算法更是显然，因为b%a一定能写成b+ka的形式，用求余只是为了让数字缩小得最快</p><p>这部分我是改来改去，因为在证欧几里得算法的过程中发现欧几里得算法是狭义的结果，我们可以直接由大推小</p><h5 id="扩展欧几里得算法">3.扩展欧几里得算法</h5><p>在说明这个之前，我们要先提一个东西——贝祖等式 <spanclass="math display">\[ax+by=gcd(a,b)\newline对于任意两个整数a，b，一定存在一组整数x，y使等式成立\]</span> 但一样的，我不想讨论负数，所以默认a，b≥0</p><p>这个等式看起来挺难让人相信的，但数学的证明经常就是用严谨的逻辑推翻人的直觉。。。</p><p><span class="math display">\[待证等式是对称等式，不妨令a≤b\newline利用欧几里得算法求gcd(a,b)的方式就是反复求余，直到其中一项为0\newline那么第一步先证明反复求余最终会有一个0\]</span> 证明： <span class="math display">\[有0≤r_2≤r_1且r_1，r_2不同时为0\newline当r_2=r_1时显然求余会得0\newline当r_2&lt;r_1时:\newliner_{n+1}=r_{n-1}\%r_{n}\quad(r_n≠0)\newliner_{n+1}=r_n\quad(r_n=0)\newline所以当r_n≠0时r_{n+1}严格小于r_n\newline即r在r_n=0前是递减数列，至多经过r_1项后，即r_{r_{1}+1}一定是0\newline所以如此反复求余后一定会有0\newline\]</span> 回过来看 <span class="math display">\[gcd(r_2,r_1)=gcd(r_3=r_1\%r_2,r_2)=gcd(r_4=r_2\%r_3,r_3)=gcd(r_5=r_3\%r_4,r_4)=...=gcd(r_{n+1}=r_{n-1}\%r_n,r_n)=...\newline=gcd(r_{k+1}=0,r_k&gt;0)=r_k\]</span>将r<sub>2</sub>，r<sub>1</sub>视作贝祖等式里的a，b，那么gcd(a,b)=gcd(r<sub>2</sub>,r<sub>1</sub>)=r<sub>k</sub>，所以我们要找到一组整数x，y，能够满足r<sub>2</sub>x+r<sub>1</sub>y=r<sub>k</sub></p><p>因为我们不可能一步步从r<sub>3</sub>算到r<sub>k</sub>，对于这种步数不确定的东西，我们可以使用归纳法</p><p>证明: <span class="math display">\[仅讨论r_n&gt;0的情况\newline令r_n=p_nr_2+q_nr_1\quad(n≥3)\newline现证明任意p_n,q_n(n≥3)均为整数\newline显然的，r_3=r_1\%r_2可以写作r_3=p_3r_2+q_3r_1的形式，且p_3,q_3均为整数\newline令整数m满足r_4=r_2\%r_3=r_2-mr_3=r_2-m(p_3r_2+q_3r_1)=(1-mp_3)r_2-mq_3r_1\newline=p_4r_2-q_4r_1\newline显然p_4=(1-mp_3),q_4=mq_3均为整数\newline\newliner_{i-1}=p_{i-1}r_2+q_{i-1}r_1\newliner_{i}=p_{i}r_2+q_{i}r_1\newline假设p_{i-1},q_{i-1},p_{i},q_{i}均为整数\newliner_{i+1}=r_{i-1}\%r_{i}=p_{i+1}r_{2}+q_{i+1}r_{1}\newline现在要证明p_{i+1},q_{i+1}是整数\newline整数k满足r_{i+1}=r_{i-1}\%r_{i}=r_i-kr_{i-1}=(p_{i}r_2+q_{i}r_1)-k(p_{i-1}r_2+q_{i-1}r_1)\newline=(p_i-kp_{i-1})r_2+(q_i-kq_{i-1})r_1\newline显然p_{i+1}=(p_i-kp_{i-1})，q_{i+1}=(q_i-kq_{i-1})均为整数\newline所以对任意r_n&gt;0，r_n=p_nr_2+q_nr_1\quad(n≥3)\newline都有p_n,q_n为整数\]</span> 自然就有 <span class="math display">\[ax+by=gcd(a,b)\newline对于任意两个整数a，b，一定存在一组整数x，y使等式成立\]</span></p><p>扩展欧几里得算法相对于欧几里得算法多了个计算其中的x，y，即贝祖系数的功能</p><p>剩余部分待补充</p><h3 id="正解说明">4.正解说明</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span></span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span></span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span></span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span></span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">I = gmpy2.invert(q,p)</span><br><span class="line">mp = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">mq = <span class="built_in">pow</span>(c,dq,q)               <span class="comment">#求幂取模运算</span></span><br><span class="line"></span><br><span class="line">m = (((mp-mq)*I)%p)*q+mq       <span class="comment">#求明文公式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(m))          <span class="comment">#转为十六进制</span></span><br></pre></td></tr></table></figure><p>其中 <span class="math display">\[dp=d\%(p-1)\newlinedq=d\%(q-1)\]</span> 解答：</p><p><span class="math display">\[c^d=c^{k_1(p-1)+dp}=(c^{p-1})^{^{k_1}}c^{dp}\newline一般情况下，c和p是互质的(不互质的概率太小，忽略)\newline由费马小定理可以知道\newlinec^{p-1}≡1\quad(mod\space p)⇨(c^{p-1})^{^{k_1}}≡1\quad(mod\spacep)\newline⇨(c^{p-1})^{^{k_1}}-1=k_2p⇨(c^{p-1})^{^{k_1}}=k_2p+1\newline所以c^d=(c^{p-1})^{^{k_1}}c^{dp}=(k_2p+1)c^{dp}≡c^{dp}\quad(mod\spacep)\newline即c^d≡c^{dp}≡mp\quad(mod\space p)\]</span> 同理有 <span class="math display">\[m≡c^d≡mp\quad(mod\space p)\newlinem≡c^d≡mq\quad(mod\space q)\newline\]</span> 接下来证明 <span class="math display">\[m = (((mp-mq)*I)\%p)*q+mq\newline\newline中国剩余定理告诉我们\newlinem≡mp\quad(mod\space p)\newlinem≡mq\quad(mod\space q)\newline同时满足这两个方程的m存在且唯一\newline那我们只需要说明\newline(((mp-mq)I)\%p)*q+mq≡mp\quad(mod\space p)\newline(((mp-mq)I)\%p)*q+mq≡mq\quad(mod\space q)\newline\]</span> . <span class="math display">\[设x=kp+r\newline(x\quad mod\space p)y=ry\newlinexy=(kp+r)y=kpy+ry\newline所以有(x\quad mod\space p)y≡xy\quad(mod\space q)\newline\]</span> . <span class="math display">\[所以\newline(((mp-mq)I)\%p)*q+mq≡(mp-mq)Iq+mq\quad(mod\space p)\newline我们知道Iq≡1\quad(mod\space p)⇨Iq-1=kp⇨Iq=kp+1\newline(mp-mq)Iq+mq=kp(mp-mq)+mp-mq+mq≡mp\quad(mod\space p)\]</span> 后者就很显然 <span class="math display">\[(((mp-mq)I)\%p)*q+mq\newline(((mp-mq)I)\%p)*q含有因子q，所以\newline(((mp-mq)I)\%p)*q+mq≡mq\quad(mod\space q)\newline\]</span> 如此就能说明m = (((mp-mq)*I)%p)*q+mq这步是正确的</p><p>只不过最后的数字需要utf-8解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m = (((mp-mq)*I)%p)*q+mq       <span class="comment">#求明文公式</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(m))          <span class="comment">#转为十六进制</span></span><br><span class="line">hex_str=<span class="built_in">hex</span>(m)</span><br><span class="line">hex_str = hex_str[<span class="number">2</span>:]</span><br><span class="line">flag = <span class="built_in">bytes</span>.fromhex(hex_str).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>说实话我还不知道这部要怎么联想</p><p>但不过把数字扔给ai应该它看的出来</p><h3 id="瞎想">5.瞎想</h3><p><span class="math display">\[m≡c^d≡mp\quad(mod\space p)\newlinem≡c^d≡mq\quad(mod\space q)\newline\]</span></p><p>我既然已经知道这两个等式，为什么我不用中国剩余定理来解m？</p><p>说不准这个方式也是可行</p><p>如果也是正解的话那可能比原本搜到的答案更容易想到？</p><p>毕竟搜出来的解给我一种先射箭后画靶的感觉，根本想不到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span></span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span></span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span></span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span></span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I = gmpy2.invert(q,p)</span></span><br><span class="line"><span class="string">mp = pow(c,dp,p)</span></span><br><span class="line"><span class="string">mq = pow(c,dq,q)               #求幂取模运算</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">m = (((mp-mq)*I)%p)*q+mq       #求明文公式</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">mp = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">mq = <span class="built_in">pow</span>(c,dq,q)   </span><br><span class="line"></span><br><span class="line">y1=gmpy2.invert(q,p)</span><br><span class="line">y2=gmpy2.invert(p,q)</span><br><span class="line">m=(mp*q*y1+mq*p*y2)%(p*q)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(m))          <span class="comment">#转为十六进制</span></span><br><span class="line">hex_str=<span class="built_in">hex</span>(m)</span><br><span class="line">hex_str = hex_str[<span class="number">2</span>:]</span><br><span class="line">flag = <span class="built_in">bytes</span>.fromhex(hex_str).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>跑了一下，可行</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于这题难到我了，所以做个md来记录&lt;/p&gt;
&lt;h3 id=&quot;题目内容&quot;&gt;&lt;a
href=&quot;%5BBUUCTF在线评测%5D(https://buuoj.cn/challenges#RSA1)&quot;&gt;1.题目内容&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
p =
8637633767257008567099653486541091171320491509433615&#92;newline447539162437911244175885667806398411790524083553445158113&#92;newline502227745206205327690939504032994699902053229
&#92;newline&#92;newline
q =
126406749739964727691760479371708834209270508214800&#92;newline1058159313713537247388059561373733763062975257734614703928&#92;newline4030082593490776630572584959954205336880228469
&#92;newline&#92;newline
dp =
650079570221683462110904235119326153065004384105625&#92;newline2930930949663358625016881832840728066026150264693076109354&#92;newline874099841380454881716097778307268116910582929
&#92;newline&#92;newline
dq =
783472263673553449019532580386470672380574033551303&#92;newline8891379117604388816836745560980982567956735122019630021754&#92;newline38762767516968043599582527539160811120550041
&#92;newline&#92;newline
c =
24722305403887382073567316467649080662631552905960&#92;newline22939907910799560215441817605633580063888752761416407353043&#92;newline7657085079676157350205351945222989351316076486&#92;newline5735995760419783398722659250627643185360890073102702785261596&#92;newline78937431903862892400747915525118983959970607&#92;newline934142974736675784325993445942031372107342103852&#92;newline&#92;newline
&#92;]&lt;/span&gt; 其中 &lt;span class=&quot;math display&quot;&gt;&#92;[
dp=d&#92;%(p-1)&#92;newline
dq=d&#92;%(q-1)
&#92;]&lt;/span&gt; 已知这些数字，解RSA原文吧</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>费马小定理</title>
    <link href="https://red-ice-drhi.github.io/2025/01/24/Fermat&#39;s-little-theorem/"/>
    <id>https://red-ice-drhi.github.io/2025/01/24/Fermat&#39;s-little-theorem/</id>
    <published>2025-01-23T18:00:00.000Z</published>
    <updated>2025-02-18T08:53:27.948Z</updated>
    
    <content type="html"><![CDATA[<p>费马小定理</p><p>要学数论肯定会遇见这个东西</p><p>它的结论就是很简单一个式子 <span class="math display">\[a^p≡a\quad(mod\space p)\]</span> 其中p是个质数，a是任意自然数</p><span id="more"></span><p>但我觉得证明它这件事是蛮有趣的</p><p>去年暑假打mai的人多，我是坐在mai机前想破脑袋也没想出来</p><p>当时上网搜基本都是群论或者其他我没学过的东西</p><p>我就想着，证明这东西这么难吗？这种东西费马是怎么敢不写证明就跟朋友交流的</p><p>要是我有什么主意但不写证明我觉得我朋友会打死我(</p><p>当我刚认识到这个定理时，感觉这东西好反直觉，但好像又有点道理，因为p既是指数也是模数，而且还得是个质数，肯定有什么东西在里面</p><p>因为那会我才只知道同余两侧能同加减这种还算符合直觉的结论</p><p>我这人蛮懒的，不认识的东西能不学就不学，所以没耐心去了解群论</p><p>后面真的在网上找到了连高中生都能明白的证明，我十分喜欢它</p><p>用的是二项式定理+数学归纳法</p><p>第一次看到这种证明法是在这里</p><p><a href="https://zhuanlan.zhihu.com/p/87611586">费马小定理（Fermat'sLittle Theorem）</a></p><p>我这篇文章只是相当学了以后把这个方法抄一遍</p><p>由于数论中只研究整数，不像实数一样连续，数学归纳法在高中课本里属于随便讲一下的知识，在这里就成了强而有力的武器</p><p>那对谁归纳呢？</p><p>p？不太合适，因为它是质数，在自然数上它不会连续</p><p>所以不妨对a作归纳，因为a是任意自然数</p><p>证明： <span class="math display">\[0^p≡0\quad(mod\space p)\]</span> 这不就废话</p><p>那现在只需要 <span class="math display">\[假设k^p≡k\quad(mod\space p)\newline证明(k+1)^p≡k+1\quad(mod\space p)\]</span> 看着同余式感觉没有头绪，还是把它转化成我们熟悉的等式吧 <spanclass="math display">\[即\newline假设fn=k^p-k\newline求证p|(k+1)^p-(k+1)\]</span> 接下来要么用k<sup>p</sup>-k来凑(k+1)<sup>p</sup>-(k+1)</p><p>要么在(k+1)<sup>p</sup>-(k+1)中找k<sup>p</sup>-k</p><p>虽然后者也不简单，但感觉前者的难度更抽象，所以还是拆括号吧</p><p>对于这种括号带指数，我们只能用牛老爷的二项式定理暴力撕开它 <spanclass="math display">\[(k+1)^p-(k+1)=C_p^0+C_p^1k+C_p^2k^2+...+C_p^{p-1}k^{p-1}+C_p^pk^p-(k+1)\]</span> 只要熟悉组合数，那么就很容易能发现 <spanclass="math display">\[C_p^0=1,C_p^pk^p=k^p\]</span> 所以就剩下 <span class="math display">\[(k+1)^p-(k+1)=C_p^1k+C_p^2k^2+...+C_p^{p-1}k^{p-1}+(k^p-k)\]</span> 要们现在的目的是根据别人画好的靶来射箭</p><p>我们已经明白p能够整除这一坨，根据分配律也就是里面随便拎一个项出来都是p的倍数</p><p>其中(k<sup>p</sup>-k)已经是p的倍数了，那么就剩下一堆的组合数乘k的相加</p><p>那这个倍数会来自k,k<sup>2</sup>,k<sup>3</sup>...k<sup>p</sup>吗？那不应该</p><p>如果我们觉得它对，那也就是在说任意自然数的1-p都会是p的倍数，那费马小定理就不该这么写了</p><p>或者说，这个k只是个路人，它可以是任何数，我们并不关心它是多少。只要p满足条件，那么同余式就成立。就像飘洋过海，我们关心的是船，只要船符合条件了就能够过海，不论上面载的是谁，但船不行就会翻，不论载的是谁</p><p>那么证明的方向也就不可能是k</p><p>只能剩下C<sub>p</sub><sup>1</sup>,C<sub>0</sub><sup>2</sup>...C<sub>p</sub><sup>p-1</sup>了<span class="math display">\[C_p^n=\frac{p!}{n!(p-n)!}=p\frac{(p-1)!}{n!(p-n)!}\]</span> 简单用定义式拆一下</p><p>就很明显 <span class="math display">\[C_p^n是整数,p是整数\newline那么\frac{(p-1)!}{n!(p-n)!}是整数\newline所以C_p^n是p的倍数\newline即(k+1)^p-(k+1)=C_p^0+C_p^1k+C_p^2k^2+...+C_p^{p-1}k^{p-1}+C_p^pk^p-(k+1)是p的倍数\]</span> 如此我们就证明了费马小定理</p><p>吗？</p><p>有没有发现，到这里，我们还没用过一个条件——p是质数</p><p>如果这样就能得证，我随便就有一个反例 <span class="math display">\[2^4≡2\quad(mod\space 4)\newline这显然不成立吧\]</span> 这里就是有一个小陷阱。我想了十几分钟才明白，我是笨蛋😢</p><p>两数相乘得整数，其中一数是整数，另一因数是整数吗？</p><p>如果你还说：这不废话吗，难道还要整数乘小数才能得整数？</p><p>那你再想两秒钟，是不是发现不对了？ 2*0.5是多少？10*0.3是多少？</p><p>是不是，一下就能明白错在哪</p><p>分子和分母可以约分啊！</p><p>我们希望另一因数是整数，不然我们就证不出费马小定理</p><p>重新审视一下问题 <span class="math display">\[C_p^n=\frac{p!}{n!(p-n)!}=p\frac{(p-1)!}{n!(p-n)!}\newline是题设的质数，C_p^n是组合数\newline组合数从其诞生的由来就决定它一定是整数(或者你想想阶乘的定义都能明白为什么它是整数)\newline很明显的是\frac{(p-1)!}{(p-n)!}一定是整数，结合n的取值范围和阶乘的定义就能明白\newlineC_p^n=p\frac{(p-1)!}{n!(p-n)!}=p\frac{\frac{(p-1)!}{(p-n)!}}{n!}\]</span>我们不要去正着思考，<strong>什么条件</strong>下右边那一坨会是整数</p><p>思考这个"<strong>什么条件</strong>"想想就复杂不是吗？</p><p>实际上我们并不关心能满足题意的所有情况</p><p>我们只是想知道，<strong>p是质数</strong>这个条件够不够让右边那一侧成为整数</p><p>n∈[1,p-1]，那么n!最多也就是1*2*...(p-2)(p-1)</p><p>里面每一个因子都是小于p的数</p><p>对于质数p，任何小于p的数都与它互质</p><p>所以p不可能与n!有公因数，也就是没法约分</p><p>如果这种情况下右边那一坨还不是整数的话，乘积一定会留有一个不可约的分母，使得乘积不为整数</p><p>所以只能推断右边那坨是整数 <span class="math display">\[所以(k+1)^p-(k+1)=C_p^0+C_p^1k+C_p^2k^2+...+C_p^{p-1}k^{p-1}+C_p^pk^p-(k+1)一定是p的倍数\]</span> 由此我们证明了费马小定理 <span class="math display">\[a^p≡a\quad(mod\space p)\newlinea是任意自然数，p是任意质数\]</span>如果a和p互质的话(因为p是质数，要使a和p互质，只需要a不是p的倍数就行)</p><p>还能写成 <span class="math display">\[a^{p-1}≡1\quad(mod\space p)\newlinea是任意自然数，p是任意质数，且a和p互质\]</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;费马小定理&lt;/p&gt;
&lt;p&gt;要学数论肯定会遇见这个东西&lt;/p&gt;
&lt;p&gt;它的结论就是很简单一个式子 &lt;span class=&quot;math display&quot;&gt;&#92;[
a^p≡a&#92;quad(mod&#92;space p)
&#92;]&lt;/span&gt; 其中p是个质数，a是任意自然数&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PHP环境配置</title>
    <link href="https://red-ice-drhi.github.io/2024/11/18/php-enviro-set/"/>
    <id>https://red-ice-drhi.github.io/2024/11/18/php-enviro-set/</id>
    <published>2024-11-18T09:27:02.000Z</published>
    <updated>2024-11-18T17:11:41.649Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下自己配置php环境的过程</p><p>我选择官方php解释器+vscode的方案</p><span id="more"></span><p>先进入<ahref="https://www.php.net/">PHP官网</a>，点击上方的Downloads，我选择最新版本的Windowsdownload，可根据实际需求选择</p><p><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20175737.png" /></p><p>我们就能得到这样的压缩包</p><p><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20173209.png" /></p><p>找一个位置解压。由于它最外层没有文件夹，建议解压的时候自己先建一个文件夹再进去解压，或是勾选“解压在同名目录下”之类的选项</p><p><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20173424.png" /></p><p>我选择了后者，解压到了这个地方</p><p>接下来配置环境变量</p><p>在系统变量里的Path里新加php.exe所在的路径</p><p><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20173711.png" /></p><figure><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20173805.png"alt="路径要根据实际情况选择，这里仅作示例" /><figcaptionaria-hidden="true">路径要根据实际情况选择，这里仅作示例</figcaption></figure><p>打开cmd输入php -v，出现正常返回则说明变量配置成功</p><figure><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20173932.png"alt="有没有管理员权限都一样" /><figcaption aria-hidden="true">有没有管理员权限都一样</figcaption></figure><p>然后进入vscode，安装这些插件</p><p><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20174202.png" /></p><p>其中PHP Server的功能可以讲讲</p><p>安装完成后，界面上应该会出现这样的按钮（没有的话就重启vscode看看）</p><p><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20174338.png" /></p><p>单击一下它会把当前php文件挂载到自己电脑的服务器上运行，随后弹出浏览器浏览该页面</p><p>但浏览完成后记得关闭服务器，否则会报错"Server is already running"</p><p>在vscode的界面上按下CTRL+SHIFT+P</p><p><imgsrc="../img/php-enviro-set/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20174907.png" /></p><p>点击这个选项就可以停止服务器了</p><p>这个选项可能会被埋在下面，我是因为用过所以在最顶上</p><p>这样子就算大致讲完了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下自己配置php环境的过程&lt;/p&gt;
&lt;p&gt;我选择官方php解释器+vscode的方案&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一些隐写术</title>
    <link href="https://red-ice-drhi.github.io/2024/11/14/steganography/"/>
    <id>https://red-ice-drhi.github.io/2024/11/14/steganography/</id>
    <published>2024-11-13T16:48:23.000Z</published>
    <updated>2024-11-18T04:01:50.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图片的lsb隐写">1.图片的LSB隐写</h3><p>LSB，即Least Significant Bit，最低有效位。</p><p>LSB隐写的大致思路就是通过更改文件里的最低有效位，在尽少影响文件的情况下隐秘地写入信息</p><p>最常见的方式是在图片中隐写信息，如文本</p><span id="more"></span><p>图片由像素构成，常见的颜色通道是(A)RGB</p><p>那么我们可以在每个颜色的最后一位动点手脚，反正不是0就是1，要么增或减1，要么就完全没变</p><p>可以让255变成254，或者就根本不变。一个单位的差距，人类肉眼凡胎实在难以察觉。考虑到实际，不同显示器也有色差，色域或其它的不同，这点问题可以直接让颜色最低位的改变带来的影响微乎其微</p><p>借此，我们就可以把文本按bit拆分，写入到每个颜色里的最后一位。然后读取的时候按同样的规则把bit拼接起来就能得到原文，没意识到图片被动手脚的人自然难以发现异常</p><p>但需要注意的是，隐写需要保证数据不被破坏，所以<strong>不能使用JPG隐写</strong>，JPG使用了有损压缩。但例如PNG使用无损压缩，BMP根本就不压缩</p><figure><imgsrc="../img/hiding-by-LSB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(255).png"alt="mc加光影好看" /><figcaption aria-hidden="true">mc加光影好看</figcaption></figure><p>让我们在这个PNG文件里面隐写"Herobrine"进去如何？</p><p>我在<ahref="https://blog.csdn.net/Myon5/article/details/130882443">这里</a>找到了可用的隐写程序。这部分我被AI卡了好几天，因为它写不出能找到隐写内容的程序。。。</p><p>程序和使用方式我就不复制出来了</p><figure><imgsrc="../img/hiding-by-LSB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-17%20143306.png"alt="cmd" /><figcaption aria-hidden="true">cmd</figcaption></figure><figure><img src="../img/hiding-by-LSB/output.png" alt="output" /><figcaption aria-hidden="true">output</figcaption></figure><p>果然是一点区别都没有（看起来）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9b5fb0f424711f9a3651ecfb37763750    #input</span><br><span class="line">31d2118725c3f3bc4ef63ea450f2d7a3#output</span><br></pre></td></tr></table></figure><p>但是MD5不会骗人，这说明两张图片并非一个文件</p><p>接下来就使用Stegslove打开output.png，点击Analyse-DataExtract，如图中勾选，点击Preview</p><figure><imgsrc="../img/hiding-by-LSB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-17%20180246.png"alt="Stegslove" /><figcaption aria-hidden="true">Stegslove</figcaption></figure><p>看，起头的文字是什么？就是我们想要隐写的"Herobrine"<del>很有八年前看mc都市传说的感觉</del></p><p>对于BMP的LSB隐写也是一样的操作，连程序都不用换</p><h3 id="接续式的文件隐藏">2.接续式的文件隐藏</h3><p>在网上没有找到这种隐写方式有什么特定的称呼，我就暂且起这个名</p><p>这个方法其实很简单，用的特性就是压缩软件会自己在文件中寻找zip的文件标识并且忽视其他部分</p><p>例如我们把最上面的png文件(input.png)做一个副本后用wxMEdit打开，再选择你想隐藏的zip文件，同样用wxMEdit打开(这里我选择上次使用过的hello.zip)</p><figure><imgsrc="../img/steganography/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20015500.png"alt="input - 副本.png" /><figcaption aria-hidden="true">input - 副本.png</figcaption></figure><figure><imgsrc="../img/steganography/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20015513.png"alt="hello.zip" /><figcaption aria-hidden="true">hello.zip</figcaption></figure><p>这里我们直接选中hello.zip的窗口，CTRL+A，CTRL+C带走，转到input -副本.png的窗口，找到最后的地方，直接CTRL+V拼接进去</p><p>CRTL+S保存，大功告成</p><p>这个步骤其实也可以用一个cmd命令完成</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> /b &lt;file1&gt;+&lt;file2&gt; &lt;file3&gt;</span><br></pre></td></tr></table></figure><p>意思就是在二进制的方式下把file2的内容接续进file1以此生成file3</p><p>所以这一个步骤就可以写成</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> /b input.png+hello.zip &lt;custom_name&gt;.png</span><br></pre></td></tr></table></figure><p>这时候用图片查看器查看图片仍然是看不出区别，甚至可以说看起来根本没变化</p><figure><img src="../img/steganography/input%20-%20%E5%89%AF%E6%9C%AC.png"alt="input - 副本.png" /><figcaption aria-hidden="true">input - 副本.png</figcaption></figure><p>但有趣的是，如果我们把后缀名从png改成zip，它会变成可读的压缩文件，并且文件与原本的压缩包一模一样</p><figure><imgsrc="../img/steganography/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20020632.png"alt="input - 副本.zip" /><figcaption aria-hidden="true">input - 副本.zip</figcaption></figure><p>当然拼接后文件大小理论上是两者之和。所以如果一个图片有几百MB甚至上GB那基本就是有问题（分辨率超级超级高应该不常见）</p><p><imgsrc="../img/steganography/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20021641.png" /></p><p>但像现在的情况就是一个文本的压缩包能有几个大小？根本不可能从大小判断</p><p>怎么寻找它的隐写内容？</p><p>这次我们使用的隐写载体是PNG，在一般情况下，PNG一定会以0x[00 00 00 0049 45 4E 44 AE 42 6082]结束，那么我们就查找这一块，看看这部分后面还有没有东西</p><p><imgsrc="../img/steganography/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-18%20024539.png" /></p><p>显然是有的（你看里面还有"IEND"这几个字）。PNG文件内容到这十二个字节就是结束，这之后还有只能说明这个文件里不止有这个PNG。</p><p>对不同类型的隐写载体我们自然要使用对应的结束表示来寻找</p><p>但像BMP这种没有结束标识的文件就比较难搞，我们只能通过图片宽高等信息来判断图片结束位置，再看后面有没有东西</p><p>在这12个字节之后，后面4个字节是0x[50 4B 0304]，这是zip压缩源文件数据区的标识段，我们便可以猜测这剩下的部分是zip文件</p><p>所以我们就可以把这剩下的部分复制走制作一个新文件，用压缩软件打开，正好我们就可以看见一个完整的压缩包内容。</p><p>那如果对方不讲武德不放在最后而是放在最前或者是中间呢？我试验过了，这样子做会让图片无法打开所以没有意义。</p><p>实际上这种隐写方式适用于大多数类型文件里面隐藏zip，甚至是编程作业的exe（正经的不知道，毕竟真的不好验证是否影响功能）。就很神奇，大部分文件只会根据文件信息读取属于自己的数据块，但起始信息一定要处于文件开头。但zip读取的时候它对应的数据块可以是在文件的任何地方</p><p>但实际上这种方式可以隐藏任意文件，以zip示例的原因只是它就算被隐藏了也能打得开，其他类型则不一定</p><p>只要能看出表文件的结尾后面还有没有东西我们就可以看出它有没有隐藏别的文件</p><p>（或许会再更新）</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;图片的lsb隐写&quot;&gt;1.图片的LSB隐写&lt;/h3&gt;
&lt;p&gt;LSB，即Least Significant Bit，最低有效位。&lt;/p&gt;
&lt;p&gt;LSB隐写的大致思路就是通过更改文件里的最低有效位，在尽少影响文件的情况下隐秘地写入信息&lt;/p&gt;
&lt;p&gt;最常见的方式是在图片中隐写信息，如文本&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>同余的初步研究</title>
    <link href="https://red-ice-drhi.github.io/2024/11/02/congruence-modulo/"/>
    <id>https://red-ice-drhi.github.io/2024/11/02/congruence-modulo/</id>
    <published>2024-11-01T17:50:20.000Z</published>
    <updated>2025-02-18T08:55:14.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何为同余">1.何为同余</h3><p>数论啊，兜兜转转还是回到了这里</p><p>这里并不会像教材一样严格讨论定义，重点还是会用，会算就行</p><p>可能字面会错，但我能保证意思不会差</p><p>仅仅是记录我的学习过程</p><p>数论研究的是整数，所以以下的所有字母默认均为属于整数</p><span id="more"></span><p>什么是余数？</p><p>这还用想吗，被除数-商*除数就是余数</p><p>但如果被除数是负数呢？越减越小，减减更快乐？所以我们不应该只将其定义为“被除数减去除数直到其小于除数后的那个数”。</p><p>想一想 <span class="math display">\[(-3)÷2\]</span>这玩意应该余啥？我们都把负数专门拿出来讨论了，那只输出本体或是固定的负无穷大那就没意思了</p><p>何必拘泥于减法呢？我们可以看看加法 <span class="math display">\[(-3)+2=-1\]</span></p><p>啥？你跟我说-3除以2余1？确实，我就是想说这个</p><p>或者说实际上我们并不是想知道它严格上的余数到底是什么，我们只想要一个对人类而言最简单易懂的结果</p><p>例如一天有24小时，每天早上八点有课</p><p>我们会理解为</p><div style="text-align:center;font-weight:bold;">我们每天八点有课（二十四小时值，不强调早上晚上，直接数值体现）</div><p>而不会说</p><div style="text-align:center;font-weight:bold;">我们在...负四十点，负十六点，八点，三十二点，五十六点...有课</div><p>在“我们每天八点有课”中，我们已经不关心是哪一天了，反正昨天有，今天有，明天也有。我们觉得每一天的八点都一样要上课，那就不必拘泥于到底是哪一天，八点和三十二点已经在暗中被画上了等号</p><p>我们可以称24为“模”，也就是模为24的情况下，-40，-16，8，32，56是等价的，也就是这些数在模24的情况下都可以写成8。虽说要写32，56什么的也没什么问题，但最简单的8多好看</p><p>所以，我们就不需要拘泥于余数的定义有没有被除数为负数的情况，而是直接认识到它们是等价的</p><p>那除数为负数呢？</p><p>无所谓的，对于一天的时间，减24和加24终究是回到原点，所以模-24和模24是一样的，那我们还不如直接把模数都写成正的，好看也好理解</p><p>至此，为了方便记录这些等式，我们就可以给出定义</p><p><span class="math display">\[a≡b\quad(mod\space n)\]</span> 这个式子可以理解为a%n==b%n的意思，a与b除以p所得余数相同</p><p>它也可以说成</p><div style="text-align:center;font-weight:bold;">a与b模p同余</div><p>其中n就称为“模”或者“模数”（一般来讲，n≠0，毕竟n=0求余也没什么意义）</p><p>或者说</p><div style="text-align:center;font-weight:bold;">a与b在模p下相同</div><p>它有一个<strong>等价</strong>形式 <span class="math display">\[n|(a-b)\]</span> 等等，“|”又是什么东西？</p><p>在式子 <span class="math display">\[a|b\]</span> 中，它一般叫做“a整除b”，可以理解说是b%a==0 ，但更准确的定义是<span class="math display">\[b=ka\quad k∈Z\]</span> 毕竟b有可能是负数</p><p>所以上面的式子也就是n整除a-b，或者说，存在一个整数k，使得kn=a-b</p><p>说实话一开始我还觉得左边是除数右边是被除数的形式看着难受，但永远不要小看人的适应能力。多看多用，总会习惯</p><p>但是，你有没有发现，明明两种形式都有各自的定义，我却在两者之间强行插上了“等价”二字</p><p>这个加粗不是为了强调，而只是想让你产生怀疑</p><p>说怀疑也怀疑不到哪里去吧应该。毕竟，从小学一年级就开始认识数字，加减乘除的我们会觉得这个“等价”会是个不证自明的东西</p><p>如果你觉得它不证自明，那我猜测你的想法是：a和b应该是能被拆成能整除的部分和不能整除的部分，相减一下，欸，不能整除的部分没了！</p><p>其实证明这个等价也就是这么回事</p><p>先来试试前推后</p><p>由 <span class="math display">\[a≡b\quad(mod\space n)\]</span>说明存在k<sub>1</sub>和k<sub>2</sub>，使得a=k<sub>1</sub>n+p<sub>1</sub>，b=k<sub>2</sub>n+p<sub>2</sub>（p<sub>1</sub>,p<sub>2</sub>∈[0,n-1]）</p><p>显然的，a对n求余是p<sub>1</sub>，b对n求余是p<sub>2</sub>，由上面，我们对同余式的定义可以得到p<sub>1</sub>=p<sub>2</sub></p><p>那我们就将p<sub>1</sub>，p<sub>2</sub>都记为p，即令p=p<sub>1</sub>=p<sub>2</sub></p><p>那么就有 <span class="math display">\[a-b=(k_1n+p-(k_2n+p))=n(k_1-k_2)\]</span> 说明a-b是n的倍数，即n整除a-b</p><p>现在逆推，由 <span class="math display">\[n|(a-b)\]</span> 也就是 <span class="math display">\[a-b=kn⇨a=b+kn\]</span></p><p><span class="math display">\[a≡b\quad(mod\space n)⇨b+kn≡b\quad(mod\space n)\]</span></p><p>显然的，(b+kn)%n==b%n，因为就是相差整数倍的n，有上面等式成立</p><p>至此我们证明了两种表达是等价的</p><p>这最后一步的证明也隐含了同余的重要性质： <spanclass="math display">\[a≡a+kn\quad(mod\space n)\quad k∈Z\]</span> 这个我觉得没什么必要证明了，从定义就能明白</p><h3 id="同余的基本性质">2.同余的基本性质</h3><p>同余式既然长得像个等式，肯定是因为人们发现它具有等式的一些性质才会这么做，因为这样理解和使用更加便捷</p><p>那就让我们一步步看</p><h4 id="自反性">1.自反性</h4><p>即 <span class="math display">\[a≡a\quad(mod\space n)\quad\]</span> 任何数都与自身同余，这里不做证明</p><h4 id="对称性">2.对称性</h4><p><span class="math display">\[a≡b\quad(mod\space n)⇦⇨b≡a\quad(mod\space n)\quad\]</span></p><p>这里不作证明</p><h4 id="传递性">3.传递性</h4><p><span class="math display">\[a≡b\quad(mod\space n),b≡c\quad(mod\space n)⇨a≡c\quad(mod\space n)\quad\]</span></p><p>证明： <span class="math display">\[a≡b\quad(mod\space n)⇨n|(a-b)⇨k_1n=(a-b)\newlineb≡c\quad(mod\space n)⇨n|(b-c)⇨k_2n=(b-c)\]</span> 两式相加得 <span class="math display">\[(k_1+k_2)n=a-c⇨n|(a-c)⇨a≡c\quad(mod\space n)\]</span></p><h4 id="加减模数为自身">4.加减模数为自身</h4><p>第一条就是前面说的 <span class="math display">\[a≡a+kn\quad(mod\space n)\quad k∈Z\]</span></p><h4 id="左右可同加减同余式">5.左右可同加减（同余式）</h4><p><span class="math display">\[a≡b\quad(mod\space n)⇦⇨a+x≡b+x\quad(mod\space n)\]</span></p><p>证明：可将其化为 <span class="math display">\[n|a-b⇦⇨n|(a+x)-(b+x)\]</span></p><p>所以两者均可相互转化。正着转换是加法，反过来就是减法，或者说减一个数就是加上其相反数，一样的方法就能证明，这里省略</p><p>那如果 <span class="math display">\[a≡b\quad(mod\space n)\newlinec≡d\quad(mod\space n)\]</span> 会有 <span class="math display">\[a+c≡b+d\quad(mod\space n)\]</span> 吗？</p><p>答案是肯定的 <span class="math display">\[a≡b\quad(mod\space n)⇨n|(a-b)⇨jn=a-b\newlinec≡d\quad(mod\space n)⇨n|(c-d)⇨kn=c-d\newline(j+k)n=(a+c)-(b+d)⇨n|(a+c)-(b+d)⇨\newlinea+c≡b+d\quad(mod\space n)\]</span> 两侧相减也是同理，此处不作证明</p><h4 id="左右可同乘同余式">6.左右可同乘（同余式）</h4><p><span class="math display">\[a≡b\quad(mod\space n)⇨ka≡kb\quad(mod\space n)\quad k∈Z\]</span></p><p>证明： <span class="math display">\[a≡b\quad(mod\spacen)⇨n|(a-b)⇨jn=a-b⇨jkn=k(a-b)⇨n|k(a-b)⇨n|ka-kb⇨ka≡kb\quad(mod\space n)\]</span></p><p>同样，也有 <span class="math display">\[a≡b\quad(mod\space n)\newlinec≡d\quad(mod\space n)\newline⇨ac≡bd\quad(mod\space n)\]</span> 但证明方式得稍微拐个弯</p><p>尝试： <span class="math display">\[a≡b\quad(mod\space n)⇨n|(a-b)⇨jn=a-b\newlinec≡d\quad(mod\space n)⇨n|(c-d)⇨kn=c-d\newlinejkn^2=ac-ad-bc+bd\]</span> 这样的等式与我们期望的结果不符</p><p>那我们就该重新想想</p><p>我们操作等式的重心一定要在n上吗</p><p>如果说这条性质是正确的，只要我们凑出ad-bc，它等号的对侧一定是能够写成n乘上什么什么的形式</p><p>至于n旁边的数是什么，我们并不关心</p><p>但ad-bc在哪？如果你的注意力比较涣散的话可能就难以发现(其实就是移项避免分配律乱配)，反正我就是这样我是笨蛋😢我还是问GPT才意识到的</p><p>现在我们看不出ad-bc在哪，我也不想看。</p><p>那不然我们就试试找出ad或者bc，相对于我们想要的结果kn=ac-bd也就是移一个项的事</p><p>看看上面，感觉b和d比较好表示，那我们就算算bd</p><p>证明： <span class="math display">\[a≡b\quad(mod\space n)⇨n|(a-b)⇨jn=a-b⇨b=jn+a\newlinec≡d\quad(mod\space n)⇨n|(c-d)⇨kn=c-d⇨d=kn+c\newlinebd=jkn^2+jcn+kan+ac⇨(jkn+jc+ka)n=bd-ac⇨n|bd-ac\newline⇨ac≡bd\quad(mod\space n)\]</span> 你看，这样表示bd确实就是kn+ac的形式，由此就能得证了</p><h4 id="除呢我同除呢">7.除呢？我同除呢？</h4><p>拔说了，直接上反例 <span class="math display">\[4≡2\quad(mod\space 2)\]</span> 这个同余式没什么问题，但两侧同除2后 <spanclass="math display">\[2≡1\quad(mod\space 2)\]</span> 你说这怎么可能嘛</p><p>但也不是所有情况都不能同除 <span class="math display">\[20≡50\quad(mod\space 3)⇨(同除5)⇨4≡10\quad(mod\space 3)\]</span>20和50模3都余2没什么问题，4和10模3都余1也没问题，同余式仍然成立</p><p>并不是所有情况都可以同除，但也不是所有情况不能同除。</p><p>即使如此，<strong>我们一般也不认为同余具有除法性质</strong></p><p>但我觉得同余两侧同除一个数会发生什么是一个很好玩的思维游戏 <spanclass="math display">\[a≡b\quad(mod\space n)⇨n|(a-b)⇨kn=a-b⇨\frac{kn}{m}=\frac{a-b}{m}\]</span></p><p>当然，这里m能够整除a和b，以后除法默认可整除</p><p>因为(a-b)/m是整数，所以<strong>kn/m也是整数</strong></p><p>或者也可以如此说明kn/m是整数 <span class="math display">\[kn=a-b⇨a=kn+b\newline\frac{a}{m}=\frac{b+kn}{m}=\frac{b}{m}+\frac{kn}{m}\]</span> 虽然kn/m是板上钉钉的事，但我总觉得这个表达形式让我心痒痒</p><p>m是a和b的公因数，也就是b和kn+b的公因数</p><p>m确实和k有这么一层关系，但总觉得，很不直观</p><p>要不然换种表达吧 <span class="math display">\[da≡db\quad(mod\space n)⇨n|da-db⇨kn=d(a-b)⇨\frac{kn}{d}=a-b\]</span> 这次我们不控制差值了，而是控制公因数d</p><p>也就是 <span class="math display">\[k=\frac{d(a-b)}{n}\]</span> 是不是直观多了</p><p>现在回到正题，什么时候能整除，什么时候不能整除？</p><p>如果要 <span class="math display">\[a≡b\quad(mod\space n)⇦⇨n|(a-b)⇦⇨\frac{k}{d}∈Z\]</span> 说明当d能整除k的时候两侧可以同除</p><p>那如果我不听话，硬是同除呢？</p><p>kn/d是整数，但d不整除k，那我们可以将其看作 <spanclass="math display">\[\frac{kn}{d}=\frac{gcd(k,d)k_1n}{gcd(k,d)d_1}=k_1\frac{n}{d_1}\newline其中gcd(a,b,...)表示括号内所有数的最大公因数\newline令k=gcd(k,d)k_1\space,\space d=gcd(k,d)d_1\]</span>因为kn/d是整数，k<sub>1</sub>是整数，那必然有n/d<sub>1</sub>是整数</p><p>这样就可以写成 <span class="math display">\[da≡db\quad(mod\space n)⇨a≡b\quad(mod\space\frac{n}{d_1})⇨a≡b\quad(mod\space\frac{gcd(k,d)n}{d})⇨a≡b\quad(mod\space\frac{gcd(\frac{d(a-b)}{n},d)n}{d})\]</span>显然地有，当d整除k，有d<sub>1</sub>=1，因为这时候gcd(k,d)=d</p><p>所以这个推理是对任意d成立的，因为d要么整除k，要么不整除k</p><p>但我觉得这个式子可能没什么实际价值，太抽象了，单纯推着玩。</p><p>同时我们也可以发现，表达法多种多样，毕竟你只要找到一个a-b能被一个数整除，你可以写出类似的式子</p><p>像gpt喜欢说 <span class="math display">\[da≡db\quad(mod\space n)⇨a≡b\quad(mod\space \frac{n}{gcd(d,n)})\]</span> 然后说，当d和n互质时，两侧就可以同除</p><p>证法是类似的，这个推理也是正确的 <span class="math display">\[\frac{kn}{d}=\frac{gcd(n,d)n_2k}{gcd(n,d)d_2}=\frac{k}{d_2}n_2\]</span> 也就是说，当n和d互质时，两侧同除d是能保证模数n不变的</p><p>因为n和d互质，那只能让d整除k才能保证kn/d是整数</p><p>那反过来想想，如果两侧除以d后，在模数不变的情况下同余式仍成立</p><p>可以说明d一定整除k吗？可以说明d和n一定互质吗？</p><p>前者是可以的，因为a-b=kn/d，由同余式的定义可知k/d一定是整数</p><p>对于后者，我们已经知道了k/d，那么一定会有gcd(n,d)=1？不见得</p><p>想证伪最简单的办法就是举反例</p><p>找k，n，d使得d整除k并且n和d有公因数</p><p>不妨令k=4，n=6，d=2，那么kn=24=da-db</p><p>也就是da=db+24，不妨令b=1，有 <span class="math display">\[26≡2\quad(mod\space 6)\]</span> 这个同余式没有问题</p><p>尝试左右两侧同除2 <span class="math display">\[13≡2\quad(mod\space 6)\]</span> 仍没有问题，但是gcd(n,d)≠1</p><p>也就是，同余式两侧有公因数d的情况下</p><p>d整除k是同余式两侧同除d但模数不变后同余式仍然成立的充要条件</p><p>d和n互质是同余式两侧同除d但模数不变后同余式仍然成立的充分不必要条件</p><p>其实我猜测同除这件事可能跟高中学的向量运算比较相似，既没有这个性质，平时应该遇不上这种问题。就像我们平时见不到向量除向量一样，我们应该也见不到同余除以同余，这时由其性质决定的，因为没有什么实际含义，所以没有对应的情况能表达出这种东西</p><h4 id="左右可同求幂">8.左右可同求幂</h4><p>像一般等式一样 <span class="math display">\[a=b⇨a^c=b^c\]</span> 我们也希望有 <span class="math display">\[a≡b\quad(mod\space n)⇨a^c≡b^c\quad(mod\space n)\]</span> 其实这个问题很简单，因为我们已经知道了 <spanclass="math display">\[a≡b\quad(mod\space n)\newlinec≡d\quad(mod\space n)\newline⇨ac≡bd\quad(mod\space n)\]</span> 那剩下就是归纳法的事了</p><p>证明：</p><p>显然有 <span class="math display">\[a≡b\quad(mod\space n)⇨a^2≡b^2\quad(mod\space n)\]</span> 并且有 <span class="math display">\[若a^k≡b^k\quad(mod\space n)\newline则a^{k+1}≡b^{k+1}\quad(mod\space n)\]</span> 所以 <span class="math display">\[a≡b\quad(mod\space n)⇨a^c≡b^c\quad(mod\space n)\]</span> 得证</p><h3 id="结">结</h3><p>同余式常用的基本性质大致就这些。</p><p>像同除，同开跟，同取对数之类的运算一般不会去深究，因为一般不会出现，而且这些运算容易产生分数和无理数</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;何为同余&quot;&gt;1.何为同余&lt;/h3&gt;
&lt;p&gt;数论啊，兜兜转转还是回到了这里&lt;/p&gt;
&lt;p&gt;这里并不会像教材一样严格讨论定义，重点还是会用，会算就行&lt;/p&gt;
&lt;p&gt;可能字面会错，但我能保证意思不会差&lt;/p&gt;
&lt;p&gt;仅仅是记录我的学习过程&lt;/p&gt;
&lt;p&gt;数论研究的是整数，所以以下的所有字母默认均为属于整数&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>zip破解与伪加密</title>
    <link href="https://red-ice-drhi.github.io/2024/11/02/zip-encrypting/"/>
    <id>https://red-ice-drhi.github.io/2024/11/02/zip-encrypting/</id>
    <published>2024-11-01T17:50:20.000Z</published>
    <updated>2024-11-06T07:58:07.928Z</updated>
    
    <content type="html"><![CDATA[<p>今天来研究以下zip的破解与伪加密</p><h3 id="破解密码">1.破解密码</h3><p>当你不知道一个压缩包的密码但你又想解压它的时候该怎么办？能想到的确实只有多试硬破</p><p>只不过这不像一般的登录密码，错多了直接把你锁住</p><p>所以“多试”这个活我们就可以直接扔给电脑做</p><p>我们能做的就是尽可能搜集线索，例如“密码只有数字”，“密码有6位字符”之类这样的</p><p>这些线索可以大幅缩减穷举范围，让电脑少费很多功夫</p><p>不然64位的随机字符组成的密码足够电脑破几百万年</p><span id="more"></span><p>现在让我们做点破解密码的实验</p><figure><imgsrc="../img/zip-encrypting/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-02%20023057.png"alt="hello.txt" /><figcaption aria-hidden="true">hello.txt</figcaption></figure><p>如图所示，这是一个名为"hello.txt"的记事本，里面写着"lucky andhappy!"（感叹号是英文字符）</p><p>用bandizip把它压缩成一个密码是114514的zip文件</p><p>接下来我们用<ahref="https://www.52pojie.cn/thread-1691394-1-1.html">Advanced ArchivePassword Recovery</a>（AAPR）来破解它</p><h4 id="暴力破解">1.暴力破解</h4><p>直接选择暴力破解，勾选所有可以打印字符，长度设定1-10</p><p><imgsrc="../img/zip-encrypting/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-02%20025848.png" /></p><p>口令长度=5这台电脑就花了大概十分钟，现在来到了6位长度，看到五小时我不想等了</p><p>这次我我把暴力范围选项框定在了所有数字里，结果这次我的电脑只花了12ms</p><p><imgsrc="../img/zip-encrypting/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-02%20030205.png" /></p><p>总之暴力破解真的就是让电脑一个一个试，所以框定范围能够显著地减少时间</p><h4 id="掩码爆破">2.掩码爆破</h4><p>使用这个方式的前提是你知道某一位或几位是什么字符并且你知道这个密码有几位字符</p><p>例如我设置掩码为“1？？？？？4”，再在暴力范围选项里选中所有可打印字符</p><p><imgsrc="../img/zip-encrypting/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-02%20032452.png" /></p><p>只花了1.3s就破出来了，掩码确实大幅减少了破解时间</p><h4 id="字典爆破">3.字典爆破</h4><p>这个方式吧，我觉得可能局限性比较大。一般能收录在爆破词典里的密码都不会太复杂，甚至有规律。例如AAPR里自带的english.dic里面真的就是英语单词，自然是爆破不成功的。</p><p>但我觉得如果说对方为了安全性整了很多复杂的密码，但他又记不住，于是写了份密码册，然后你能通过某种手段搞到对方的密码册，那确实可以做到字典爆破</p><h4 id="python脚本">4.Python脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">startTime = time.time()</span><br><span class="line"><span class="comment"># 判断线程是否需要终止</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">password, file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        password = <span class="built_in">str</span>(password)</span><br><span class="line">        file.extractall(path=<span class="string">&#x27;.&#x27;</span>, pwd=password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;the password is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(password))</span><br><span class="line">        nowTime = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;spend time is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(nowTime-startTime))</span><br><span class="line">        <span class="keyword">global</span> flag</span><br><span class="line">        <span class="comment"># 成功解压其余线程终止</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_main</span>():</span><br><span class="line">    zfile = zipfile.ZipFile(<span class="string">&quot;path\\to\\you\\file&quot;</span>, <span class="string">&#x27;r&#x27;</span>)  <span class="comment">#这里选中你的zip</span></span><br><span class="line">    <span class="comment"># 开始尝试</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>, <span class="number">999999</span>):   <span class="comment">#为了省时间，就不从1开始了</span></span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            t = threading.Thread(target=extract, args=(number, zfile))</span><br><span class="line">            t.start()</span><br><span class="line">            t.join()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    do_main()</span><br></pre></td></tr></table></figure><p>得到输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Bad password for file &#x27;hello.txt&#x27;</span><br><span class="line">Bad password for file &#x27;hello.txt&#x27;</span><br><span class="line">Bad password for file &#x27;hello.txt&#x27;</span><br><span class="line">Bad password for file &#x27;hello.txt&#x27;</span><br><span class="line">Bad password for file &#x27;hello.txt&#x27;</span><br><span class="line">Bad password for file &#x27;hello.txt&#x27;</span><br><span class="line">Bad password for file &#x27;hello.txt&#x27;</span><br><span class="line">the password is 114514</span><br><span class="line">spend time is 23.434365034103394</span><br></pre></td></tr></table></figure><p>确实破出来了</p><h3 id="zip伪加密">2.zip伪加密</h3><h4 id="进制拆解">1.16进制拆解</h4><p>在实现这一步之前，我想我们需要学习十六进制下的zip文件结构</p><figure><imgsrc="../img/zip-encrypting/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-05%20000613.png"alt="hello.zip" /><figcaption aria-hidden="true">hello.zip</figcaption></figure><p>仍然使用wxMEdit来打开hello.zip(没有密码)</p><p>需要注意的是，zip的数据使用字节内顺读，字节外逆读的方式，这点对数量有关的数据很重要</p><p>如0x[AB CD]对应的数字不是0xABCD而是0xCDAB</p><figure><imgsrc="../img/zip-encrypting/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-05%20000613-1730745798198-2.png"alt="zip" /><figcaption aria-hidden="true">zip</figcaption></figure><p>触摸板没法画得特别好</p><p>这里面有三对花括号，颜色为蓝绿红。这是zip文件的三个部分</p><table><colgroup><col style="width: 49%" /><col style="width: 17%" /><col style="width: 32%" /></colgroup><thead><tr><th>压缩源文件数据区</th><th>核心目录</th><th>目录结束标志</th></tr></thead><tbody><tr><td>local file header + file data + data descriptor</td><td>central directory</td><td>end of central directory record</td></tr></tbody></table><h5 id="压缩源文件数据区">1.压缩源文件数据区</h5><p>数据区由一系列本地文件记录组成</p><p>这一段以0x[50 4B 03 04]（顺）开头，标志其开始</p><p>local file header里面会记录一些概述信息，稍后列表详细解释</p><p>file data是文件的压缩数据。我们这里不深究其压缩算法</p><p>datadescriptor不太重要，故这里不做探究（至少在文件里没有出现，并且网上没有太多人做解释）</p><table><colgroup><col style="width: 8%" /><col style="width: 7%" /><col style="width: 84%" /></colgroup><thead><tr><th>Offset</th><th>Bytes</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td>4</td><td>标识段0x[50 4B 03 04]</td></tr><tr><td>0x04</td><td>2</td><td>解压文件所需版本，记录解压缩文件所需的最低支持的ZIP规范版本</td></tr><tr><td>0x06</td><td>2</td><td>通用位标记，[0000 0L0J 00000000]，若J这位(hello.zip中为0)为1则说明文件被加密，若L这位(hello.zip中为0)为1则说明有数据描述部分，其他部分貌似不常见</td></tr><tr><td>0x08</td><td>2</td><td>压缩方式</td></tr><tr><td>0x0A</td><td>2</td><td>文件最后修改时间，使用MS-DOS格式编码的时间</td></tr><tr><td>0x0C</td><td>2</td><td>文件最后修改日期，使用MS-DOS格式编码的日期</td></tr><tr><td>0x0E</td><td>4</td><td>CRC-32校验码</td></tr><tr><td>0x12</td><td>4</td><td>压缩后的大小，单位为字节，hello.zip中为0x[12 00 0000]=18字节，这里即hello.txt的原始大小</td></tr><tr><td>0x16</td><td>4</td><td>未压缩的大小，单位为字节，hello.zip中为0x[10 00 0000]=16字节，这里为压缩包里hello.txt的大小</td></tr><tr><td>0x1A</td><td>2</td><td>文件名长度，单位为字节，hello.zip中为0x[09 00 00 00]=9字节</td></tr><tr><td>0x1C</td><td>2</td><td>扩展名长度，单位为字节，hello.zip中为0x[00 00 00 00]=0字节</td></tr><tr><td>0x1E</td><td>可变</td><td>文件名，hello.zip中此段对应hello.txt</td></tr><tr><td>0x27</td><td>可变</td><td>扩展区，一般情况下不使用</td></tr></tbody></table><p>当前最低功能版本定义如下：（压缩包记录的解压版本都是需要版本*10，如hello.zip中记录为0x[1400]=20=2.0*10）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.0 – 默认值</span><br><span class="line">1.1 – 文件是卷标</span><br><span class="line">2.0 – 文件是一个文件夹（目录）</span><br><span class="line">2.0 – 使用 Deflate 压缩来压缩文件</span><br><span class="line">2.0 – 使用传统的 PKWARE 加密对文件进行加密</span><br><span class="line">2.1 – 使用 Deflate64™ 压缩文件</span><br><span class="line">2.5 – 使用 PKWARE DCL Implode 压缩文件</span><br><span class="line">2.7 – 文件是补丁数据集</span><br><span class="line">4.5 – 文件使用 ZIP64 格式扩展</span><br><span class="line">4.6 – 使用 BZIP2 压缩文件压缩</span><br><span class="line">5.0 – 文件使用 DES 加密</span><br><span class="line">5.0 – 文件使用 3DES 加密</span><br><span class="line">5.0 – 使用原始 RC2 加密对文件进行加密</span><br><span class="line">5.0 – 使用 RC4 加密对文件进行加密</span><br><span class="line">5.1 – 文件使用 AES 加密进行加密</span><br><span class="line">5.1 – 使用更正的 RC2 加密对文件进行加密</span><br><span class="line">5.2 – 使用更正的 RC2-64 加密对文件进行加密</span><br><span class="line">6.1 – 使用非 OAEP 密钥包装对文件进行加密</span><br><span class="line">6.2 – 中央目录加密</span><br></pre></td></tr></table></figure><p>压缩方式编码如下，看看就好，不必细究，hello.zip中为0x[08 00]=8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 – The file is stored (no compression)</span><br><span class="line">1 – The file is Shrunk</span><br><span class="line">2 – The file is Reduced with compression factor 1</span><br><span class="line">3 – The file is Reduced with compression factor 2</span><br><span class="line">4 – The file is Reduced with compression factor 3</span><br><span class="line">5 – The file is Reduced with compression factor 4</span><br><span class="line">6 – The file is Imploded</span><br><span class="line">7 – Reserved for Tokenizing compression algorithm</span><br><span class="line">8 – The file is Deflated</span><br><span class="line">9 – Enhanced Deflating using Deflate64™</span><br><span class="line">10 – PKWARE Data Compression Library Imploding</span><br><span class="line">11 – Reserved by PKWARE</span><br><span class="line">12 – File is compressed using BZIP2 algorithm</span><br></pre></td></tr></table></figure><p>这张图是MS-DOS编码时间和日期的方式。查到的资料是这样，但实际上我发现hello.zip里的数据换不出正确的，但bandizip里能正确显示，暂且略过</p><figure><img src="../img/zip-encrypting/21774-20231110120033061-1649867627.png"alt="MS-DOS" /><figcaption aria-hidden="true">MS-DOS</figcaption></figure><h5 id="核心目录">2.核心目录</h5><p>核心目录由一系列文件记录组成，一个文件记录对应数据区的一个压缩文件记录</p><table><colgroup><col style="width: 30%" /><col style="width: 5%" /><col style="width: 64%" /></colgroup><thead><tr><th>Offset(为方便查找，接续上表)</th><th>Bytes</th><th>Description</th></tr></thead><tbody><tr><td>0x39</td><td>4</td><td>核心目录文件头标识0x[50 4B 01 02]</td></tr><tr><td>0x3D</td><td>2</td><td>压缩所用版本，同上</td></tr><tr><td>0x3F</td><td>2</td><td>解压所需版本，同上</td></tr><tr><td>0x41</td><td>2</td><td>通用位标记，同上</td></tr><tr><td>0x43</td><td>2</td><td>压缩方法，同上</td></tr><tr><td>0x45</td><td>2</td><td>文件最后修改时间</td></tr><tr><td>0x47</td><td>2</td><td>文件最后修改日期</td></tr><tr><td>0x49</td><td>4</td><td>CRC-32校验码</td></tr><tr><td>0x4D</td><td>4</td><td>压缩后大小</td></tr><tr><td>0x51</td><td>4</td><td>未压缩大小</td></tr><tr><td>0x55</td><td>2</td><td>文件名长度</td></tr><tr><td>0x57</td><td>2</td><td>扩展区长度，此处不同上，为0x[24 00]=36字节</td></tr><tr><td>0x59</td><td>2</td><td>文件注释长度</td></tr><tr><td>0x5B</td><td>2</td><td>文件开始位置的磁盘编号，此处为0x[00 00]</td></tr><tr><td>0x5D</td><td>2</td><td>内部文件属性</td></tr><tr><td>0x5F</td><td>4</td><td>外部文件属性</td></tr><tr><td>0x63</td><td>4</td><td>本地文件头的相对位移，记录对应数据内对应文件记录相对于压缩包起始的位置偏移量。hello.zip中为0x[0000 00 00]因为一开始就是对应记录</td></tr><tr><td>0x67</td><td>可变</td><td>文件名，同样为hello.txt</td></tr><tr><td>0x70</td><td>可变</td><td>扩展区，此处长度为上面规定的36字节</td></tr><tr><td>此处无</td><td>可变</td><td>文件注释目录结束标志</td></tr></tbody></table><h5 id="目录结束标志">3. 目录结束标志</h5><table><colgroup><col style="width: 30%" /><col style="width: 5%" /><col style="width: 64%" /></colgroup><thead><tr><th>Offset(为方便查找，接续上表)</th><th>Bytes</th><th>Description</th></tr></thead><tbody><tr><td>0x94</td><td>4</td><td>核心目录结束标记0x[50 4B 05 06]</td></tr><tr><td>0x98</td><td>2</td><td>核心目录尾部位置所在磁盘编号，此处为0x[00 00]</td></tr><tr><td>0x9A</td><td>2</td><td>核心目录开始位置所在磁盘编号，此处为0x[00 00]</td></tr><tr><td>0x9C</td><td>2</td><td>该磁盘上记录的核心目录数量，此处为0x[01 00]</td></tr><tr><td>0x9E</td><td>2</td><td>zip压缩包中文件总数，此处为0x[01 00]</td></tr><tr><td>0xA0</td><td>4</td><td>整个核心目录大小，单位为字节，此处为0x[5B 00 0000]=91字节，也就是图中绿花括号所含字节数</td></tr><tr><td>0xA4</td><td>4</td><td>核心目录开始位置相对位移，此处为0x[39 00 0000]，图中第3行第9个字节正式核心目录开始位置</td></tr><tr><td>0xA8</td><td>2</td><td>注释内容长度，此处为0x[00 00 00 00]</td></tr><tr><td>此处无</td><td>可变</td><td>注释内容</td></tr></tbody></table><p>至此整个hello.zip就算粗略地分析完毕了，但到此为止也够用</p><h4 id="通过wxmedit实现伪加密">2.通过wxMEdit实现伪加密</h4><p>通过修改核心目录区的通用位标记就可以实现伪加密</p><p>在hello.zip里是0x41的位置，原本为0x[00 00]这里我们把它改成0x[0100]后保存</p><p>再打开bandizip试图打开hello.txt，显示我们需要输入密码</p><figure><imgsrc="../img/zip-encrypting/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-06%20154356.png"alt="需要输入密码" /><figcaption aria-hidden="true">需要输入密码</figcaption></figure><p>如此就实现了伪加密</p><p>那破除伪加密的方法之一就很显然</p><p><strong>修改通用位标记</strong></p><p>但也有其他方法，如</p><p><strong>在 Mac OS 及部分 Linux(如 Kali ) 系统中，可以直接打开伪加密的ZIP 压缩包</strong></p><p><strong>使用工具ZipCenOp.jar</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来研究以下zip的破解与伪加密&lt;/p&gt;
&lt;h3 id=&quot;破解密码&quot;&gt;1.破解密码&lt;/h3&gt;
&lt;p&gt;当你不知道一个压缩包的密码但你又想解压它的时候该怎么办？能想到的确实只有多试硬破&lt;/p&gt;
&lt;p&gt;只不过这不像一般的登录密码，错多了直接把你锁住&lt;/p&gt;
&lt;p&gt;所以“多试”这个活我们就可以直接扔给电脑做&lt;/p&gt;
&lt;p&gt;我们能做的就是尽可能搜集线索，例如“密码只有数字”，“密码有6位字符”之类这样的&lt;/p&gt;
&lt;p&gt;这些线索可以大幅缩减穷举范围，让电脑少费很多功夫&lt;/p&gt;
&lt;p&gt;不然64位的随机字符组成的密码足够电脑破几百万年&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>十六进制下的图片</title>
    <link href="https://red-ice-drhi.github.io/2024/10/25/pictures-in-HEX/"/>
    <id>https://red-ice-drhi.github.io/2024/10/25/pictures-in-HEX/</id>
    <published>2024-10-25T10:20:41.000Z</published>
    <updated>2024-11-01T17:46:33.409Z</updated>
    
    <content type="html"><![CDATA[<p>根据任务内容，我开始用wxMEdit查看图片文件，尝试研究计算机眼里的图片</p><figure><imgsrc="../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20170601.png"alt="神奇东西" /><figcaption aria-hidden="true">神奇东西</figcaption></figure><p>我利用Windows画图制作了这么一张简单的3*4的图片。</p><p>里面的颜色都是由0或255组成，便于研究</p><span id="more"></span><h3 id="png">1.PNG</h3><figure><imgsrc="../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-25%20183557.png"alt="神奇东西.png" /><figcaption aria-hidden="true">神奇东西.png</figcaption></figure><p>果然十六进制不是给人类读的</p><p>但在上网一番学习后，我也对其有了一定的理解</p><figure><img src="../img/pictures-in-HEX/opng.png" alt="Hpng" /><figcaption aria-hidden="true">Hpng</figcaption></figure><p>00行：00-07这8个字节是代表png格式的Header，或者说是png文件的固定开头，这样子电脑才能知道这是个png文件（01-03的ASCII转换过来就是PNG，有点意思）</p><p>现在再来了解一个东西：数据块</p><p>因为除开png头部分其他都可视作数据块的组成</p><p>数据块由下面四个部分组成</p><table><colgroup><col style="width: 37%" /><col style="width: 7%" /><col style="width: 55%" /></colgroup><thead><tr><th style="text-align: center;">名称</th><th style="text-align: center;">字节数</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr><td style="text-align: center;">Length(长度)</td><td style="text-align: center;">4</td><td style="text-align: center;">指明Chunk Data的长度，单位：字节</td></tr><tr><td style="text-align: center;">Chunk Type Code(数据块类型码)</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">规定数据块类型，其名称即由ASCII对应字符确定</td></tr><tr><td style="text-align: center;">Chunk Data(数据块实际内容)</td><td style="text-align: center;">可变</td><tdstyle="text-align: center;">最重要的内容部分，其长度由Length决定</td></tr><tr><td style="text-align: center;">CRC(循环冗余检测)</td><td style="text-align: center;">4</td><td style="text-align: center;">存储用来检测是否有错误的循环冗余码</td></tr></tbody></table><p>其中，数据块还分为关键数据块和辅助数据块</p><p>关键数据块必须存在，辅助数据块可有可无。通常以大写字母开头的为关键数据块，以小写字母开头的为辅助数据块</p><p>那么现在我们就跟着上面我做了注释的图来初步了解一些数据块吧</p><h4 id="ihdr">1.IHDR</h4><p>第00行的08-0B说明了有个数据实际内容长0x0D=13字节的数据块，是什么数据块呢？从接下去的0C-0F可以看出是IHDR数据块</p><p>这个数据块中的实际内容储存着这个png文件的一些重要信息</p><table><colgroup><col style="width: 13%" /><col style="width: 4%" /><col style="width: 46%" /><col style="width: 35%" /></colgroup><thead><tr><th style="text-align: center;">名称</th><th style="text-align: center;">字节数</th><th style="text-align: center;">解释</th><th style="text-align: center;">实例说明</th></tr></thead><tbody><tr><td style="text-align: center;">Width</td><td style="text-align: center;">4</td><td style="text-align: center;">图片宽度，单位：像素</td><td style="text-align: center;">就如原图一样宽度只有3个像素</td></tr><tr><td style="text-align: center;">Height</td><td style="text-align: center;">4</td><td style="text-align: center;">图片高度，单位：像素</td><td style="text-align: center;">同理，高度是4个像素</td></tr><tr><td style="text-align: center;">Bit depth</td><td style="text-align: center;">1</td><td style="text-align: center;">图像深度： <br/>索引彩色图像：1，2，4或8<br/>灰度图像：1，2，4，8或16 <br/>真彩色图像：8或16</td><tdstyle="text-align: center;">如第一个像素是(255,0,0)纯红，255需要8个bit表示</td></tr><tr><td style="text-align: center;">ColorType</td><td style="text-align: center;">1</td><td style="text-align: center;">颜色类型：<br/>0：灰度图像,1，2，4，8或16 <br/>2：真彩色图像，8或16<br/>3：索引彩色图像，1，2，4或8<br/>4：带透明度数据(或称α通道数据)的灰度图像，8或16<br/>6：带透明度数据(或称α通道数据)的真彩色图像，8或16</td><td style="text-align: center;">文件中为06</td></tr><tr><td style="text-align: center;">Compression method</td><td style="text-align: center;">1</td><td style="text-align: center;">表示压缩算法。目前只支持 0，表示Deflate/Inflate。Deflate/inflate 是一种结合了 LZ77和霍夫曼编码的无损压缩算法，被广泛运用于 7-zip，zlib，gzip 等场景。</td><td style="text-align: center;">00</td></tr><tr><td style="text-align: center;">Filter method</td><td style="text-align: center;">1</td><tdstyle="text-align: center;">代表在压缩前应用的过滤函数类型，目前只支持0。过滤函数类型 0 里面包括了 5 种过滤函数。</td><td style="text-align: center;">00</td></tr><tr><td style="text-align: center;">Interlace method</td><td style="text-align: center;">1</td><tdstyle="text-align: center;">代表图片数据是否经过交错，0代表没有交错，1代表交错。</td><td style="text-align: center;">00即没有交错</td></tr></tbody></table><p>这个数据块的实际内容到此结束，共13字节正好，接下来4个字节是CRC校验，CRC校验暂且不是研究重点，知道有这个东西得占4个字节就好。</p><p>然后这个IHDR数据块就到此结束，让我们来看下一个数据块</p><h4 id="srgb">2.sRGB</h4><p>同理，从20行的01-04可以看出有一个数据实际内容长1个字节的数据块，再往后读四个字节05-08可以看出是sRGB数据块</p><p>这个数据块用于表示图片的色彩空间</p><p>对于这1个字节的数据实际内容，有</p><table><thead><tr><th style="text-align: center;">值</th><th style="text-align: center;">表达</th></tr></thead><tbody><tr><td style="text-align: center;">00</td><td style="text-align: center;">表示感性的，用于展示照片等</td></tr><tr><td style="text-align: center;">01</td><td style="text-align: center;">表示相对色彩，用于展示图标等</td></tr><tr><td style="text-align: center;">02</td><td style="text-align: center;">表示饱和的，用于展示图表等</td></tr><tr><td style="text-align: center;">03</td><tdstyle="text-align: center;">表示绝对色彩，用于展示图片原本的色彩</td></tr></tbody></table><p>文件中的数据实际内容为00</p><p>之后4字节的0A-0D为CRC校验，这个数据块就到这里结束了</p><h4 id="gama">3.gAMA</h4><p>可知它的实际内容长4个字节。它的功能与亮度调整，色彩管理，图像处理等方面有关。这个我们不细究。</p><p>CRC校验后数据块结束</p><h4 id="phys">4.pHYS</h4><p>它的实际内容长9个字节，它规定的是图像的物理大小</p><p>前四个字节规定X轴上每个单位长度的像素数，后四个字节规定Y轴上每个单位长度的像素数，最后一个字节规定单位是什么</p><p>例图中，x轴上每个单位长度有0x1274=4724个像素</p><p>y轴上每个单位长度有0x1274=4724个像素</p><p>单位是什么呢？，下一个字节是0x01，它对应的单位是米。</p><p>也就是一米里塞4724个像素</p><p>随后CRC检验，数据块结束</p><h4 id="idat">5.IDAT</h4><p>这个数据块是整个PNG最重要的部分，因为它储存着每个像素块的信息。毕竟没有像素块让计算机把图从何渲染起？</p><p>但PNG没有那么单纯，里面的信息是经过算法压缩的，所以储存的不是原始数据。不然里面就应该有一堆0x00和0xFF了</p><p>但事实上没有</p><p>通过一番折腾，我通过AI弄到了能够解码这个数据块的python程序，跑了一下</p><figure><imgsrc="../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-28%20210932.png"alt="python程序解码IDAT数据块" /><figcaption aria-hidden="true">python程序解码IDAT数据块</figcaption></figure><p>抄出来</p><table><colgroup><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /></colgroup><thead><tr><th>0x</th><th style="text-align: center;">00</th><th style="text-align: center;">01</th><th style="text-align: center;">02</th><th style="text-align: center;">03</th><th style="text-align: center;">04</th><th style="text-align: center;">05</th><th style="text-align: center;">06</th><th style="text-align: center;">07</th><th style="text-align: center;">08</th><th style="text-align: center;">09</th><th style="text-align: center;">0A</th><th style="text-align: center;">0B</th><th style="text-align: center;">0C</th><th style="text-align: center;">0D</th><th style="text-align: center;">0E</th><th style="text-align: center;">0F</th></tr></thead><tbody><tr><td>00</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">FF</td><td style="text-align: center;">02</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td></tr><tr><td>01</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">01</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">01</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">FF</td><td style="text-align: center;">FF</td></tr><tr><td>02</td><td style="text-align: center;">FF</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">02</td><td style="text-align: center;">FF</td><td style="text-align: center;">FF</td><td style="text-align: center;">FF</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td></tr><tr><td>03</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>在前面我们知道，这个图片的色深是8bit，每个像素的组成是RGBA</p><p>每个行的起头是一个字节的过滤器字节，其代表过滤器的类型</p><table><colgroup><col style="width: 15%" /><col style="width: 15%" /><col style="width: 69%" /></colgroup><thead><tr><th style="text-align: center;">过滤器字节</th><th style="text-align: center;">过滤器类型</th><th style="text-align: center;">过滤方式</th></tr></thead><tbody><tr><td style="text-align: center;">0x00</td><td style="text-align: center;">无</td><td style="text-align: center;">保留原始数据</td></tr><tr><td style="text-align: center;">0x01</td><td style="text-align: center;">减</td><td style="text-align: center;">减去A</td></tr><tr><td style="text-align: center;">0x02</td><td style="text-align: center;">上</td><td style="text-align: center;">减去B</td></tr><tr><td style="text-align: center;">0x03</td><td style="text-align: center;">平均</td><td style="text-align: center;">根据A，B取平均，并向下取整</td></tr><tr><td style="text-align: center;">0x04</td><td style="text-align: center;">Paeth</td><td style="text-align: center;">使用最接近于 p = A + B − C 的 A、B 或 C的数值</td></tr></tbody></table><figure><img src="../img/pictures-in-HEX/filter-functions.png"alt="A，B，C是指相对X的位置" /><figcaption aria-hidden="true">A，B，C是指相对X的位置</figcaption></figure><p>对于每一行像素，格式都是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(过滤器)[(R,G,B,A),(R,G,B,A),(R,G,B,A)...(R,G,B,A)]</span><br></pre></td></tr></table></figure><p>了解了这些前置内容，我们就可以开始正式分析图片像素了</p><p>第一行像素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(00)[(FF,00,00,FF),(00,FF,00,FF),(00,00,FF,FF)]  //其中A的FF表示完全不透明</span><br></pre></td></tr></table></figure><p>可以知道，这一行没有过滤器，</p><p>像素从左到右依次为红，黄，蓝，均不透明。与原图相符</p><p>第二行像素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(02)[(00,FF,00,00),(FF,01,FF,00),(00,FF,00,00)]</span><br></pre></td></tr></table></figure><p>过滤器0x02表示与上面相减，那么我们通过把这一行与上一行相加就可以得到原始数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(xx)[(FF,FF,00,FF),(FF,00,FF,FF),(00,FF,FF,FF)]  //其中FF+01溢出变为00</span><br></pre></td></tr></table></figure><p>就可以得到这一行的像素是</p><p>黄，紫，青，均不透明。与原图相符</p><p>第三行像素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(01)[(00,00,00,FF),(FF,FF,FF,00),(00,00,00,00)]</span><br></pre></td></tr></table></figure><p>过滤器0x01表示与左侧相减，其中第一个像素是原始数据（因为左侧没有像素）</p><p>那么从第二个像素开始，将每个像素的现数据与左侧像素(原数据)相加即可得到原始数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(xx)[(00,00,00,FF),(FF,FF,FF,FF),(FF,FF,FF,FF)]</span><br></pre></td></tr></table></figure><p>显然是黑，白，白，均不透明。与原图相符</p><p>第四行像素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(02)[(FF,FF,FF,00),(00,00,00,00),(00,00,00,00)]</span><br></pre></td></tr></table></figure><p>过滤器0x02表示与上面相减，通过把这一行与上一行(原始)相加即可得到原始数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(xx)[(FF,FF,FF,FF),(FF,FF,FF,FF),(FF,FF,FF,FF)]</span><br></pre></td></tr></table></figure><p>很明显，这一行是白，白，白，均不透明。与原图相符</p><p>至此，四行像素我们都解析完毕了，均与原图相符。之后4个字节的CRC校验，数据块结束</p><p>（这一部分真的折腾了我好几天QAQ）</p><h4 id="iend">6.IEND</h4><p>PNG文件的最后12个字节一定是0x[00 00 00 00 49 45 4E 44 AE 42 6082]</p><p>我们仍可以用数据块的角度去看待它</p><p>0x[00 00 0000]说明这个数据块实际内容长度为0。这个数据块的作用是标志文件结束，自然不需要什么内容</p><p>0x[49 45 4E 44]说明这个数据块是IEND</p><p>那既然实际内容长度为0，那就是没有实际内容</p><p>所以接下去的4个字节是CRC校验。因为前面的8个字节固定，所以CRC校验的4个字节也是固定的</p><p>就能知道PNG一定是以这12个字节结束</p><p>至此，PNG部分就算结束</p><h3 id="bmp">2.BMP</h3><p>同样一张图片，用Windows画图将其转换为BMP格式，用wxMEdit打开它。同样的，研究其数据结构</p><figure><imgsrc="../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20014755.png"alt="BMP" /><figcaption aria-hidden="true">BMP</figcaption></figure><p>对其做上标记，使其更好阅读</p><figure><imgsrc="../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20014755-1730142005375-4.png"alt="BMP注释" /><figcaption aria-hidden="true">BMP注释</figcaption></figure><p>我用方括号括出不同的数据块，在其中用横线或是尖括号标出其中的子块（触摸板画图不好操控，能看就行）</p><p>BMP的阅读方式比较怪，但总结一下就是</p><p><strong>字节外从右往左，字节内从左往右</strong></p><p>例如[AB CD]在BMP中要读作是[CD AB]</p><p>(这玩意我瞪了半天才明白，因为我发现像素一直对不上)</p><p><strong>但不同的数据块我们仍然以从左往右的顺序进行分析</strong></p><p>我们先将这个BMP分成三个大块</p><p>1.文件头(bit map file header)</p><p>2.位图信息头(bitmap information)</p><p>3.位图数据(pixel data)</p><p>（有些BMP文件还会出现调色板(colorpalette)数据块，但这里没有，我们先略过）</p><h4 id="文件头">1.文件头</h4><p>这一部分是BMP的固有开头，占14字节，其中记录了这些信息（蓝色方括）</p><table><colgroup><col style="width: 33%" /><col style="width: 11%" /><col style="width: 55%" /></colgroup><thead><tr><th style="text-align: center;">字段名</th><th style="text-align: center;">大小（字节）</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">FileType(文件类型)</td><td style="text-align: center;">2</td><td style="text-align: center;">描述其文件类型，固定为[424D]，对应ASCII中的BM</td></tr><tr><td style="text-align: center;">FileSize(文件大小)</td><td style="text-align: center;">4</td><td style="text-align: center;">记录文件大小，单位为KB，文件中为[66 0000 00]即0x66=102KB（查看文件属性，这个文件确实大小为102KB）</td></tr><tr><td style="text-align: center;">Reserved(保留位)</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">2位保留位预留给图片渲染应用，初始化必须为0（说实话我也不懂这是什么意思，但查到的资料就是这么说的）</td></tr><tr><td style="text-align: center;">Reserved(保留位)</td><td style="text-align: center;">2</td><td style="text-align: center;">同上</td></tr><tr><tdstyle="text-align: center;">PixelDataOffset(从头到位图数据的偏移)</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">例图中的值为0x36=54，即记录在位图数据开始前一共有多少个字节（你可以看一下，位图数据的第一个字节是第3行第7个（紫色方括号），也就是在位图数据开始前有0x36个字节）</td></tr></tbody></table><p>文件头数据块就到此结束</p><h4 id="位图信息头">2.位图信息头</h4><p>（橙色方括）</p><table><colgroup><col style="width: 17%" /><col style="width: 13%" /><col style="width: 68%" /></colgroup><thead><tr><th style="text-align: center;">字段名</th><th style="text-align: center;">大小（字节）</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">HeaderSize</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">信息头大小，单位是字节，例图中为0x28=40字节</td></tr><tr><td style="text-align: center;">ImageWidth</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">描述图片宽度，单位是像素，例图中为0x03=3符合事实</td></tr><tr><td style="text-align: center;">ImageHeight</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">描述图片高度，单位是像素，例图中为0x04=4符合事实</td></tr><tr><td style="text-align: center;">Planes</td><td style="text-align: center;">2</td><td style="text-align: center;">目标设备说明颜色平面数，总被设置为1</td></tr><tr><td style="text-align: center;">BitsPerPixel</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">定义每个像素需要多少个bit储存，一般有1、2、4、8、16、24、32这几种。例图中为0x18=24，因为三原色中每种颜色是0-255占8bit，一个像素就需要3*8=24bit。（这里没有透明度了）</td></tr><tr><td style="text-align: center;">Compression</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">图像的压缩类型，最常用的就是0（BI_RGB），表示不压缩（再压缩我又得折腾半年）</td></tr><tr><td style="text-align: center;">ImageSize</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">位图数据的大小，当用BI_RGB格式时，可以设置为0。例图中是0x30=48符合其大小</td></tr><tr><td style="text-align: center;">XpixelsPerMeter</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">水平分辨率，单位是像素/米，有符号整数。例图为0x1274=4724</td></tr><tr><td style="text-align: center;">YpixelsPerMeter</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">垂直分辨率，单位是像素/米，有符号整数.例图为0x1274=4724</td></tr><tr><td style="text-align: center;">TotalColors</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">位图使用的调色板中的颜色索引数，为0说明使用所有</td></tr><tr><td style="text-align: center;">ImportantColors</td><td style="text-align: center;">4</td><tdstyle="text-align: center;">对图像显示有重要影响的颜色索引数，为0说明都重要</td></tr></tbody></table><p>到此，位图信息头结束</p><h4 id="位图数据">3.位图数据</h4><p>我用紫色方括号括了起来</p><p>为什么里面会有尖括号和划线之分呢？难道像素数据不都一个样吗？</p><p>因为BMP存在在一个机制</p><p>比特填充(bit padding)</p><p>BMP扫描引擎的最小单位是4字节，所以每一行的字节数必须是4的倍数，若有不足的部分会用0x00填充</p><p>例图中每一行有三个像素，即3*3=9个字节，不是4的倍数，所以每一行会有三个0x00填充进去以达到一行12个字节，即使它不表达任何东西</p><p>如果我们从左往右看<strong>像素块</strong>（绿尖括）的话，那么它在图像内对应的顺序是从左到右，从下到上。</p><p>在一个像素内（绿尖括内），我们可以理解为<strong>字节外从右往左，字节内从左往右的RGB排列</strong></p><p>也可以理解为<strong>正常从左往右的BGR</strong></p><p>毕竟这两者一模一样，怎么理解是个人主观的问题</p><p>总之，通过位图数据的内容，我们可以轻松还原出图像的内容</p><table><thead><tr><th style="text-align: center;">红色</th><th style="text-align: center;">绿色</th><th style="text-align: center;">蓝色</th></tr></thead><tbody><tr><td style="text-align: center;">黄色（R+G）</td><td style="text-align: center;">紫色（R+B）</td><td style="text-align: center;">青色（G+B）</td></tr><tr><td style="text-align: center;">黑色</td><td style="text-align: center;">白色</td><td style="text-align: center;">白色</td></tr><tr><td style="text-align: center;">白色</td><td style="text-align: center;">白色</td><td style="text-align: center;">白色</td></tr></tbody></table><p>至此，我们成功解读完了这个BMP文件的内容</p><h3 id="jpeg">3.JPEG</h3><p>同样用Windows画图将例图保存为JPEG</p><figure><imgsrc="../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20130607.png"alt="JPEG" /><figcaption aria-hidden="true">JPEG</figcaption></figure><p>呜哇，看起来比前面两种都长都复杂</p><p>先让我们了解数据段的结构。其实跟PNG的数据块蛮类似的</p><p>以下是数据段的一般结构</p><table><colgroup><col style="width: 8%" /><col style="width: 17%" /><col style="width: 73%" /></colgroup><thead><tr><th>名称</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>段标识</td><td>1</td><td>这一个字节固定为0xFF，它标志的数据段的起始</td></tr><tr><td>段类型</td><td>1</td><td>用这一个字节说明这是什么类型的数据段</td></tr><tr><td>段长度</td><td>2</td><td>这两个字节会记录'段长度'+'段内容'的长度，单位是字节</td></tr><tr><td>段内容</td><td>'段长度'-2</td><td>记录数据段的实际内容，但是它的长度一定会≤65533字节</td></tr></tbody></table><p>有些数据段会只有段标识和段类型这两部分，如SOI和EOI</p><p>由于JPEG的压缩方式过于复杂，我在历经几天的折腾之后，仍不理解它的压缩原理以及解码方式。所以这里我只简单地标记数据块，并只作简单的讲解，无法涉及算法内容</p><figure><imgsrc="../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-29%20130607%EF%BC%881%EF%BC%89.png"alt="JPEG标注" /><figcaption aria-hidden="true">JPEG标注</figcaption></figure><h4 id="soi">1.SOI</h4><p>这个数据段只有段标识和段类型两块组成，固定为0x[FFD8]。这也是JPEG文件的固定开头</p><h4 id="app0">2.APP0</h4><p>这个数据段一个分成如下几个部分</p><table><colgroup><col style="width: 13%" /><col style="width: 14%" /><col style="width: 72%" /></colgroup><thead><tr><th>名称</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>段标识</td><td>1</td><td>固定为0xFF</td></tr><tr><td>段类型</td><td>1</td><td>E0即为APP0</td></tr><tr><td>段长度</td><td>2</td><td>例图中为0x0010=16，如果n不为0的话则是(16+3*n)D</td></tr><tr><td></td><td>以下为段内容</td><td></td></tr><tr><td>交换格式</td><td>5</td><td>例图为'JFIF'，即例图中0x[4A 46 49 4600]的ASCII对应字符(其中0x00是空字符)</td></tr><tr><td>主版本号</td><td>1</td><td>例图中为0x01，暂且不深究版本之间的区别</td></tr><tr><td>次版本号</td><td>1</td><td>例图中为0x01，暂且不深究版本之间的区别</td></tr><tr><td>密度单位</td><td>1</td><td>0＝无单位<br/>1＝像素/英寸<br/>2＝像素/厘米<br/>例图中为0x02</td></tr><tr><td>X像素密度</td><td>2</td><td>水平方向的密度 ，例图中为0x[002F]，代表47像素/厘米（？我也不是很理解）</td></tr><tr><td>Y像素密度</td><td>2</td><td>垂直方向的密度</td></tr><tr><td>缩略图X像素</td><td>1</td><td>缩略图水平像素数目 ，例图中为0x00（应该就是没有缩略图）</td></tr><tr><td>缩略图Y像素</td><td>1</td><td>缩略图垂直像素数目 ，例图中为0x00（应该就是没有缩略图）</td></tr><tr><td>RGB缩略图</td><td>3*n</td><td>例图中不存在这一段，所以n=0。当前两段数据均大于0时，这段才会存在，这时n=缩略图像素总数='缩略图X像素'*'缩略图Y像素'</td></tr></tbody></table><p>JFIF是JPEG File InterchangeForma的缩写，即JPEG文件交换格式。另外还有TIFF等格式，但很少用</p><p>像素密度的含义我也不是很理解</p><p>因为我把这张图放大64倍后用尺子在屏幕上量宽是3.4-3.5厘米之间，与像素密度不符(相符的话应该在4cm出头)。可能是指在打印机上的密度？</p><p>关于缩略图这东西，我查到的资料说是大部分JPEG都没这东西，也就是n一般都为0，所以就先不深究了</p><p>此外，一些JPEG图片可能包含APPn数据段（这里n不是上面那个n，是在1-E之间取值的一个数），它的段类型字节是0xEn。手机照片通常包含APP1，会记录时间，地点等信息。</p><h4 id="dqt">3.DQT</h4><p>这个图片文件中有两个DQT，我们都放在这里一起研究</p><table><colgroup><col style="width: 7%" /><col style="width: 15%" /><col style="width: 76%" /></colgroup><thead><tr><th>名称</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>段标识</td><td>1</td><td>固定为0xFF</td></tr><tr><td>段类型</td><td>1</td><td>DQT为0xDB</td></tr><tr><td>段长度</td><td>2</td><td>其值为3+n，例图两处DQT中n=1，所以两处段长度均为0x43</td></tr><tr><td></td><td>以下为段内容</td><td></td></tr><tr><td>QT信息</td><td>1</td><td>以两位十六进制数的视角去看这一个字节，其中高位代表QT精度，低位代表QT编号。当高位是0H时代表精度是一个字节，如果不是0H的话精度就是两个字节。例图中第一个DQT数据段中这一字节是0x00，即QT精度为1字节，QT编号为0。第二个DQT数据段中这一字节是0x01，即QT精度为1字节，QT编号为1</td></tr><tr><td>QT内容</td><td>n</td><td>其中n=64*‘QT精度’=(0x40)*‘QT精度’，其中QT精度的单位是字节。例图中两处DQT数据段QT精度均为1字节，所以两处n=64=0x40</td></tr></tbody></table><p>这个数据段应该是与压缩和解码有关，但我目前还不理解</p><h4 id="sof">4.SOF</h4><table><colgroup><col style="width: 8%" /><col style="width: 27%" /><col style="width: 63%" /></colgroup><thead><tr><th>名称</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>段标识</td><td>1</td><td>固定为0xFF</td></tr><tr><td>段类型</td><td>1</td><td>0xC0</td></tr><tr><td>段长度</td><td>2</td><td>例图中为0x0011即17字节</td></tr><tr><td></td><td>以下为段内容</td><td></td></tr><tr><td>样本精度</td><td>1</td><td>单位为bit，例图中为8，大多数软件不支持12和16。样本是单个像素的颜色分量，或者说一个样本就是一个组件。所以下面的组件ID，采样系数，量化表号等每个都占1个字节</td></tr><tr><td>图片高度</td><td>2</td><td>例图中为4，符合实际</td></tr><tr><td>图片宽度</td><td>2</td><td>例图中为3，符合实际</td></tr><tr><td>组件数量</td><td>1</td><td>1代表灰度图，3代表YCbCr/YIQ彩色图，4代表CMYK彩色图<br/>我想这个组件数量是指色彩的组件数量，如灰度图只有亮度一个组件，所以只有黑白。也可以说RGB，YCbCr，YIQ是三个组件，CMYK是四个组件</td></tr><tr><td></td><td>以下部分会重复'组件数量'次</td><td></td></tr><tr><td>组件ID</td><td>1</td><td>1代表Y, 2代表Cb, 3代表Cr, 4代表I, 5代表Q</td></tr><tr><td>采样系数</td><td>1</td><td>把这一字节当成两位十六进制数来看，高位代表垂直采样系数，低位代表水平采样系数</td></tr><tr><td>量化表号</td><td>1</td><td>这个不是很理解有什么用</td></tr></tbody></table><h4 id="dht">5.DHT</h4><p>这玩意我到处查到的信息说是定义huffman表。但要我说出具体是干什么用的。。。有生之年吧，反正肯定跟压缩算法有关</p><table><colgroup><col style="width: 7%" /><col style="width: 15%" /><col style="width: 76%" /></colgroup><thead><tr><th>名称</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>段标识</td><td>1</td><td>固定为0xFF</td></tr><tr><td>段类型</td><td>1</td><td>0xC4</td></tr><tr><td>段长度</td><td>2</td><td>其值为19+n</td></tr><tr><td></td><td>以下为段内容</td><td></td></tr><tr><td>HT信息</td><td>1</td><td>JPEG文件里有２类Haffman表：一类用于DC（直流量），一类用于AC（交流量）。一般有４个表：亮度的DC和AC，色度的DC和AC。最多可有６个。<br/>其中高位代表HT类型，0为DC表，1为AC表。低位代表HT号</td></tr><tr><td>HT位表</td><td>16</td><td>这16个数相加应≤256</td></tr><tr><td>HT值表</td><td>n</td><td>n是HT位表里16个数的和</td></tr></tbody></table><h4 id="sos">6.SOS</h4><table><colgroup><col style="width: 14%" /><col style="width: 30%" /><col style="width: 54%" /></colgroup><thead><tr><th>名称</th><th>长度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>段标识</td><td>1</td><td>0xFF</td></tr><tr><td>段类型</td><td>1</td><td>0xDA</td></tr><tr><td>段长度</td><td>2</td><td>其值＝6＋2×'扫描行内组件数量'</td></tr><tr><td></td><td>以下为段内容</td><td></td></tr><tr><td>扫描行内组件数量</td><td>1</td><td>必须属于[1,4]，通常为3，例图中也为3</td></tr><tr><td></td><td>以下部分会重复'扫描行内组件数量'次</td><td></td></tr><tr><td>组件ID</td><td>1</td><td>1代表Y, 2代表Cb, 3代表Cr, 4代表I, 5代表Q</td></tr><tr><td>Huffman表号</td><td>1</td><td>看作两位十六进制<br/>高位表示AC表号属于[0,3]<br/>低位表示DC表号属于[0,3]</td></tr><tr><td></td><td>循环体结束</td><td></td></tr><tr><td>剩余部分</td><td>3</td><td>查到的资料表示作用未知</td></tr></tbody></table><h4 id="图片压缩数据">7.图片压缩数据</h4><p>它确实不是常规数据块的格式。但暂且我也无法理解JPEG的压缩及解码方式，所以先略过</p><h4 id="eoi">8.EOI</h4><p>JPEG文件以0x[FF D9]这两个字节标志其结束</p><p>JPEG我暂且还只能写出这么多。如果我真的能理解它的解码方式的话我会补充</p><p>我尝试询问GPT，它一直说不出具体的解码方法。但它能在使用pillow库的情况下用Python写出解码程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开JPEG文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_jpeg</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> Image.<span class="built_in">open</span>(file_path) <span class="keyword">as</span> img:</span><br><span class="line">            img = img.convert(<span class="string">&#x27;RGB&#x27;</span>)  <span class="comment"># 转换为RGB格式</span></span><br><span class="line">            img.show()  <span class="comment"># 显示图像</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取像素数据</span></span><br><span class="line">            pixels = <span class="built_in">list</span>(img.getdata())</span><br><span class="line">            width, height = img.size</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 输出每个像素的RGB值</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">                    r, g, b = pixels[y * width + x]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Pixel at (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>): R=<span class="subst">&#123;r&#125;</span>, G=<span class="subst">&#123;g&#125;</span>, B=<span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error opening image: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">open_jpeg(<span class="string">&#x27;path_to_your_image.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我尝试运行，得到输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pixel at (0, 0): R=254, G=0, B=9</span><br><span class="line">Pixel at (1, 0): R=0, G=255, B=0</span><br><span class="line">Pixel at (2, 0): R=0, G=2, B=254</span><br><span class="line">Pixel at (0, 1): R=255, G=253, B=0</span><br><span class="line">Pixel at (1, 1): R=251, G=0, B=251</span><br><span class="line">Pixel at (2, 1): R=13, G=255, B=255</span><br><span class="line">Pixel at (0, 2): R=0, G=2, B=5</span><br><span class="line">Pixel at (1, 2): R=246, G=255, B=255</span><br><span class="line">Pixel at (2, 2): R=255, G=249, B=253</span><br><span class="line">Pixel at (0, 3): R=248, G=254, B=252</span><br><span class="line">Pixel at (1, 3): R=255, G=255, B=248</span><br><span class="line">Pixel at (2, 3): R=246, G=255, B=255</span><br></pre></td></tr></table></figure><p>很明显，JPEG的压缩是有失真的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据任务内容，我开始用wxMEdit查看图片文件，尝试研究计算机眼里的图片&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;../img/pictures-in-HEX/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20170601.png&quot;
alt=&quot;神奇东西&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;神奇东西&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;我利用Windows画图制作了这么一张简单的3*4的图片。&lt;/p&gt;
&lt;p&gt;里面的颜色都是由0或255组成，便于研究&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>虚拟机</title>
    <link href="https://red-ice-drhi.github.io/2024/10/24/virtual-machines/"/>
    <id>https://red-ice-drhi.github.io/2024/10/24/virtual-machines/</id>
    <published>2024-10-23T16:11:47.000Z</published>
    <updated>2024-10-23T16:56:41.389Z</updated>
    
    <content type="html"><![CDATA[<p>搭建虚拟机我选择了VMware Workstation</p><p>好像从初中就开始玩这个东西了，确实用得习惯</p><p>也装过一堆系统，不过大多数都是Windows的。XP，Visita，7，11，它们的安装方式其实都是换汤不换药</p><p>甚至装了个MS-DOS但不会用。曾经闲着没事还装过一个OpenWRT（拿Ubuntu编译的）。</p><p>安装Ubuntu，kali确实是我除安卓外第一次认真接触Linux的系统</p><p>Ubuntu其实也差不多，去官网下载镜像，配置空硬盘虚拟机，把镜像挂载在虚拟光驱上一路前进就装好了，配置虚拟网卡桥接无线网卡即可上网</p><p>kali在官网专门提供了虚拟机的版本，我就选择了它。VMware版本下出来是硬盘文件，放进VirtualMachines文件夹，再回到Workstation里扫描就出来了</p><span id="more"></span><figure><imgsrc="../img/virtual-machines/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20002414.png"alt="屏幕截图 2024-10-24 002414" /><figcaption aria-hidden="true">屏幕截图 2024-10-24 002414</figcaption></figure><figure><imgsrc="../img/virtual-machines/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-24%20002433.png"alt="屏幕截图 2024-10-24 002433" /><figcaption aria-hidden="true">屏幕截图 2024-10-24 002433</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建虚拟机我选择了VMware Workstation&lt;/p&gt;
&lt;p&gt;好像从初中就开始玩这个东西了，确实用得习惯&lt;/p&gt;
&lt;p&gt;也装过一堆系统，不过大多数都是Windows的。XP，Visita，7，11，它们的安装方式其实都是换汤不换药&lt;/p&gt;
&lt;p&gt;甚至装了个MS-DOS但不会用。曾经闲着没事还装过一个OpenWRT（拿Ubuntu编译的）。&lt;/p&gt;
&lt;p&gt;安装Ubuntu，kali确实是我除安卓外第一次认真接触Linux的系统&lt;/p&gt;
&lt;p&gt;Ubuntu其实也差不多，去官网下载镜像，配置空硬盘虚拟机，把镜像挂载在虚拟光驱上一路前进就装好了，配置虚拟网卡桥接无线网卡即可上网&lt;/p&gt;
&lt;p&gt;kali在官网专门提供了虚拟机的版本，我就选择了它。VMware版本下出来是硬盘文件，放进Virtual
Machines文件夹，再回到Workstation里扫描就出来了&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从这里开始！</title>
    <link href="https://red-ice-drhi.github.io/2024/10/22/start-here/"/>
    <id>https://red-ice-drhi.github.io/2024/10/22/start-here/</id>
    <published>2024-10-22T06:58:51.000Z</published>
    <updated>2024-10-23T16:56:56.596Z</updated>
    
    <content type="html"><![CDATA[<p>历经两三天的折腾，总算是搭建出了属于自己的博客，我十分开心</p><h3 id="搭建博客">1.搭建博客</h3><p>大体过程就是GitHub建仓库，下nodejs，下git，通过git生成ssh密钥并绑定GitHub实现免密登录</p><p>再用git下载hexo博客框架，配置完成后就可以上传至GitHub了</p><p>基本上我是参照这篇文章做的</p><p><a href="https://zhuanlan.zhihu.com/p/547520780">[2022 Hexo博客搭建和使用教程(Windows) -知乎](https://zhuanlan.zhihu.com/p/547520780)</a></p><p>大多数步骤都是结合生活常识可以解决的问题</p><p>但也有些问题卡了我很久。真的是，上网到处搜都难找答案</p><span id="more"></span><h3 id="hexo无法安装">2.hexo无法安装</h3><figure><img src="/../../img/start-here/1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>一开始看到这报错我以为是权限不足，试过给git管理员权限，降低nodejs文件夹的安全等级之类，不起用</p><p>也在浏览器上搜了一堆方法，一个是这个问题比较少见，另一个就是网上给的方法也不起用</p><p>卡了一早上一晚上，最后找到的解决方式很让人摸不着头脑</p><p><strong>用cmd执行</strong></p><p>受不了这玩意</p><h3 id="hexo-d之后博客不更新">3.hexo d之后博客不更新</h3><p>输入hexo d后即使没有报错，GitHub的仓库里的文件也确实有更新</p><p>也是一样到处搜罗没能找到适合我的答案，又这样卡了一天一夜，但是其中几个答案确实给到了我提示</p><p>最后发现在仓库的设置里找到Pages里面的Branch，把里面的branch换成_config.yml里所设置的，我这里是跟着教程设置的master所以就换了这个</p><figure><imgsrc="/../../img/start-here/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-23%20233604.png"alt="屏幕截图 2024-10-23 233604" /><figcaption aria-hidden="true">屏幕截图 2024-10-23 233604</figcaption></figure><p>如果还是不行就试试把General的Defaultbranch也改过去吧，虽然我不清楚这个有没有作用，但一开始我确实尝试过但没生效然后再改Pages里的Branch就生效了。</p><figure><imgsrc="/../../img/start-here/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-23%20235437.png"alt="屏幕截图 2024-10-23 235437" /><figcaption aria-hidden="true">屏幕截图 2024-10-23 235437</figcaption></figure><h3 id="typora">4.Typora</h3><p>在浏览器上搜索markdown的编辑器，有不少人推荐它，我也就因此选择了它</p><p>然后发现它收费</p><p>虽然不是什么光彩的事</p><p>解决方式：官网下载软件+<ahref="%5BTypora免费版安装教程（仅供学习）-CSDN博客%5D(https://blog.csdn.net/weixin_44406127/article/details/134778407)">Typora免费版安装教程（仅供学习）</a></p><h3 id="在文章里插入图片">5.在文章里插入图片</h3><p>这个不是什么难解决的问题，浏览器搜没多久就有答案了</p><p><ahref="https://blog.csdn.net/Qxiaofei_/article/details/124629908">【Hexo】GitHub+Typora写博客+图片上传</a></p><p>跟着这个做就好了</p><h3 id="从这里开始">6.从这里开始</h3><p>经过了几天的努力，我搭建起了属于自己的博客，也在自己的博客里写出了自己的第一篇文章，对我自己而言确实是个小成就。说不定未来的我遇到这样的问题还需要向这篇文章寻求帮助。这篇文章既是我在搭建博客时遇到的难题总结，也是对我搭起博客的纪念。那么，就从这里开始吧。</p><p style="color: #FFA438;font-size: 20px;">ヤバイですね☆!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;历经两三天的折腾，总算是搭建出了属于自己的博客，我十分开心&lt;/p&gt;
&lt;h3 id=&quot;搭建博客&quot;&gt;1.搭建博客&lt;/h3&gt;
&lt;p&gt;大体过程就是GitHub建仓库，下nodejs，下git，通过git生成ssh密钥并绑定GitHub实现免密登录&lt;/p&gt;
&lt;p&gt;再用git下载hexo博客框架，配置完成后就可以上传至GitHub了&lt;/p&gt;
&lt;p&gt;基本上我是参照这篇文章做的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/547520780&quot;&gt;[2022 Hexo
博客搭建和使用教程(Windows) -
知乎](https://zhuanlan.zhihu.com/p/547520780)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数步骤都是结合生活常识可以解决的问题&lt;/p&gt;
&lt;p&gt;但也有些问题卡了我很久。真的是，上网到处搜都难找答案&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://red-ice-drhi.github.io/2024/10/22/hello-world/"/>
    <id>https://red-ice-drhi.github.io/2024/10/22/hello-world/</id>
    <published>2024-10-22T03:35:15.290Z</published>
    <updated>2024-10-22T03:35:15.290Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; fo</summary>
      
    
    
    
    
  </entry>
  
</feed>
